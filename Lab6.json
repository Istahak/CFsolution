{
    "TEMPLETE": {
        "prefix": "TEMPLETE",
        "body": [
            "#include <bits/stdc++.h>",
            "#define ll long long int",
            "using namespace std;",
            "void solve()",
            "{",
            "    ",
            "}",
            "int main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    for (int cs = 1; cs <= t; cs++)",
            "    {",
            "        // cout << \"Case #\" << cs << \": \";",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "TEMPLETE"
    },
    "MAXFLOW1": {
        "prefix": "MAXFLOW1",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long int;",
            "const ll INF = LLONG_MAX;",
            "",
            "// Function to add an edge to the residual graph",
            "void addEdge(vector<vector<tuple<int, ll, ll>>> &graph, int from, int to, ll capacity)",
            "{",
            "    graph[from].emplace_back(to, capacity, 0);",
            "    graph[to].emplace_back(from, 0, 0); // Add reverse edge with 0 capacity",
            "}",
            "",
            "// Function to find an augmenting path in the residual graph using BFS",
            "bool findAugmentingPath(const vector<vector<tuple<int, ll, ll>>> &graph, vector<int> &parent, int source, int sink)",
            "{",
            "    int n = graph.size();",
            "    vector<bool> visited(n, false);",
            "    queue<int> q;",
            "    q.push(source);",
            "    visited[source] = true;",
            "",
            "    while (!q.empty())",
            "    {",
            "        int current = q.front();",
            "        q.pop();",
            "",
            "        for (auto &[to, capacity, flow] : graph[current])",
            "        {",
            "",
            "            if (!visited[to] && capacity - flow > 0)",
            "            {",
            "                parent[to] = current;",
            "                if (to == sink)",
            "                {",
            "                    return true;",
            "                }",
            "                q.push(to);",
            "                visited[to] = true;",
            "            }",
            "        }",
            "    }",
            "",
            "    return false;",
            "}",
            "",
            "// Ford-Fulkerson algorithm",
            "ll fordFulkerson(vector<vector<tuple<int, ll, ll>>> &graph, int source, int sink)",
            "{",
            "    ll maxFlow = 0;",
            "    int n = graph.size();",
            "    vector<int> parent(n, -1);",
            "",
            "    while (findAugmentingPath(graph, parent, source, sink))",
            "    {",
            "        ll pathFlow = LLONG_MAX;",
            "        for (int v = sink; v != source; v = parent[v])",
            "        {",
            "            int u = parent[v];",
            "            for (auto &[to, capacity, flow] : graph[u])",
            "            {",
            "                if (to == v)",
            "                {",
            "                    pathFlow = min(pathFlow, capacity - flow);",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "",
            "        for (int v = sink; v != source; v = parent[v])",
            "        {",
            "            int u = parent[v];",
            "            for (auto &[to, capacity, flow] : graph[u])",
            "            {",
            "",
            "                if (to == v)",
            "                {",
            "                    flow += pathFlow;",
            "                    break;",
            "                }",
            "            }",
            "",
            "            // Update the reverse edge",
            "            for (auto &[to, capacity, flow] : graph[v])",
            "            {",
            "",
            "                if (to == u)",
            "                {",
            "                    flow -= pathFlow;",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "",
            "        maxFlow += pathFlow;",
            "    }",
            "",
            "    return maxFlow;",
            "}",
            "",
            "int main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    int n, m; // Number of nodes and edges",
            "",
            "    cin >> n >> m;",
            "    vector<vector<tuple<int, ll, ll>>> graph(n);",
            "",
            "    // Input edges and capacities",
            "    for (int i = 0; i < m; i++)",
            "    {",
            "        int from, to;",
            "        ll capacity;",
            "",
            "        cin >> from >> to >> capacity;",
            "        from--, to--;",
            "        addEdge(graph, from, to, capacity);",
            "    }",
            "",
            "    int source = 0, sink = n - 1;",
            "",
            "    // cin >> source >> sink;",
            "    // source--, sink--;",
            "",
            "    ll maxFlow = fordFulkerson(graph, source, sink);",
            "",
            "    cout << maxFlow << endl;",
            "",
            "    return 0;",
            "}",
            ""
        ],
        "description": "MAXFLOW1"
    },
    "MAXFLOW2": {
        "prefix": "MAXFLOW2",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "using ll = long long int;",
            "const int N = 501;",
            "const ll INF = LLONG_MAX;",
            "",
            "int n, m;",
            "int parent[N]; // Parent array for BFS",
            "ll capacity[N][N];",
            "vector<int> adj[N]; // Adjacency list",
            "",
            "// Breadth-First Search to find augmenting paths",
            "ll bfs(int source = 1, int sink = n)",
            "{",
            "    fill(parent + 1, parent + n + 1, -1);",
            "    parent[source] = -2;",
            "",
            "    queue<pair<int, ll>> q;",
            "    q.push({source, INF});",
            "",
            "    while (!q.empty())",
            "    {",
            "        auto [u, flow] = q.front();",
            "        q.pop();",
            "",
            "        for (int v : adj[u])",
            "        {",
            "            if (parent[v] == -1 && capacity[u][v])",
            "            {",
            "                parent[v] = u;",
            "                ll aug = min(flow, capacity[u][v]);",
            "                if (v == sink)",
            "                    return aug;",
            "                q.push({v, aug});",
            "            }",
            "        }",
            "    }",
            "",
            "    return 0;",
            "}",
            "",
            "// Edmonds-Karp Max Flow Algorithm",
            "ll maxFlow(int source = 1, int sink = n)",
            "{",
            "    ll totalFlow = 0;",
            "    ll augFlow = 0;",
            "",
            "    while ((augFlow = bfs()))",
            "    {",
            "        totalFlow += augFlow;",
            "        int u = sink;",
            "        while (u != source)",
            "        {",
            "            int v = parent[u];",
            "            capacity[v][u] -= augFlow;",
            "            capacity[u][v] += augFlow;",
            "            u = v;",
            "        }",
            "    }",
            "",
            "    return totalFlow;",
            "}",
            "",
            "int main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    cin >> n >> m;",
            "",
            "    for (int i = 0; i < m; i++)",
            "    {",
            "        int u, v;",
            "        ll c;",
            "        cin >> u >> v >> c;",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "        capacity[u][v] += c;",
            "    }",
            "",
            "    ll maximumFlow = maxFlow();",
            "    cout << maximumFlow << '\\n';",
            "    return 0;",
            "}",
            ""
        ],
        "description": "MAXFLOW2"
    },
    "Dinic": {
        "prefix": "Dinic",
        "body": [
            "// Adjacency list implementation of Dinic's blocking flow algorithm.",
            "// This is very fast in practice, and only loses to push-relabel flow.",
            "//",
            "// Running time:",
            "//     O(|V|^2 |E|)",
            "//",
            "// INPUT:",
            "//     - graph, constructed using AddEdge()",
            "//     - source and sink",
            "//",
            "// OUTPUT:",
            "//     - maximum flow value",
            "//     - To obtain actual flow values, look at edges with capacity > 0",
            "//       (zero capacity edges are residual edges).",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef long long LL;",
            "",
            "struct Edge",
            "{",
            "    int u, v;",
            "    LL cap, flow;",
            "    Edge() {}",
            "    Edge(int u, int v, LL cap) : u(u), v(v), cap(cap), flow(0) {}",
            "};",
            "",
            "struct Dinic",
            "{",
            "    int N;",
            "    vector<Edge> E;",
            "    vector<vector<int>> g;",
            "    vector<int> d, pt;",
            "",
            "    Dinic(int N) : N(N), E(0), g(N), d(N), pt(N) {}",
            "",
            "    void AddEdge(int u, int v, LL cap)",
            "    {",
            "        if (u != v)",
            "        {",
            "            E.emplace_back(u, v, cap);",
            "            g[u].emplace_back(E.size() - 1);",
            "            E.emplace_back(v, u, 0);",
            "            g[v].emplace_back(E.size() - 1);",
            "        }",
            "    }",
            "",
            "    bool BFS(int S, int T)",
            "    {",
            "        queue<int> q({S});",
            "        fill(d.begin(), d.end(), N + 1);",
            "        d[S] = 0;",
            "        while (!q.empty())",
            "        {",
            "            int u = q.front();",
            "            q.pop();",
            "            if (u == T)",
            "                break;",
            "            for (int k : g[u])",
            "            {",
            "                Edge &e = E[k];",
            "                if (e.flow < e.cap && d[e.v] > d[e.u] + 1)",
            "                {",
            "                    d[e.v] = d[e.u] + 1;",
            "                    q.emplace(e.v);",
            "                }",
            "            }",
            "        }",
            "        return d[T] != N + 1;",
            "    }",
            "",
            "    LL DFS(int u, int T, LL flow = -1)",
            "    {",
            "        if (u == T || flow == 0)",
            "            return flow;",
            "        for (int &i = pt[u]; i < g[u].size(); ++i)",
            "        {",
            "            Edge &e = E[g[u][i]];",
            "            Edge &oe = E[g[u][i] ^ 1];",
            "            if (d[e.v] == d[e.u] + 1)",
            "            {",
            "                LL amt = e.cap - e.flow;",
            "                if (flow != -1 && amt > flow)",
            "                    amt = flow;",
            "                if (LL pushed = DFS(e.v, T, amt))",
            "                {",
            "                    e.flow += pushed;",
            "                    oe.flow -= pushed;",
            "                    return pushed;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    LL MaxFlow(int S, int T)",
            "    {",
            "        LL total = 0;",
            "        while (BFS(S, T))",
            "        {",
            "            fill(pt.begin(), pt.end(), 0);",
            "            while (LL flow = DFS(S, T))",
            "                total += flow;",
            "        }",
            "        return total;",
            "    }",
            "};",
            "",
            "// BEGIN CUT",
            "// The following code solves SPOJ problem #4110: Fast Maximum Flow (FASTFLOW)",
            "",
            "int main()",
            "{",
            "    int N, E;",
            "    scanf(\"%d%d\", &N, &E);",
            "    Dinic dinic(N);",
            "    for (int i = 0; i < E; i++)",
            "    {",
            "        int u, v;",
            "        LL cap;",
            "        scanf(\"%d%d%lld\", &u, &v, &cap);",
            "        dinic.AddEdge(u - 1, v - 1, cap);",
            "        dinic.AddEdge(v - 1, u - 1, cap);",
            "    }",
            "    printf(\"%lld\\n\", dinic.MaxFlow(0, N - 1));",
            "    return 0;",
            "}",
            "",
            "// END CUT"
        ],
        "description": "Dinic"
    }
}