{
    "DSU": {
        "prefix": "DSU",
        "body": [
            "class DSU",
            "{",
            "public:",
            "    int n;",
            "    vector<int> parent;",
            "    vector<int> size;",
            "    DSU(int n)",
            "    {",
            "        this->n = n;",
            "        parent.resize(n + 1);",
            "        size.resize(n + 1);",
            "        for (int i = 1; i <= n; i++)",
            "            parent[i] = i, size[i] = 1;",
            "    }",
            "    int find_set(int v)",
            "    {",
            "        if (v == parent[v])",
            "            return v;",
            "        return parent[v] = find_set(parent[v]);",
            "    }",
            "    void marge(int a, int b)",
            "    {",
            "        a = find_set(a);",
            "        b = find_set(b);",
            "        if (a != b)",
            "        {",
            "            if (size[a] < size[b])",
            "                swap(a, b);",
            "            parent[b] = a;",
            "            size[a] += size[b];",
            "        }",
            "    }",
            "};"
        ],
        "description": "DSU"
    },
    "DIJKSTRA": {
        "prefix": "DIJKSTRA",
        "body": [
            "const int N = 1e5 + 10;",
            "vector<pair<int, ll>> adj[N];",
            "const ll INF = 1e18 + 10;",
            "vector<ll> dist(N, INF);",
            "vector<int> par(N);",
            "int n, m;",
            "void dijkstra(int source)",
            "{",
            "    set<pair<ll, int>> st;",
            "    st.insert({0LL, source});",
            "    dist[source] = 0;",
            "    while (st.size() > 0)",
            "    {",
            "        auto [v_w, vertex] = *st.begin();",
            "        st.erase(st.begin());",
            "",
            "        for (auto [child, c_w] : adj[vertex])",
            "        {",
            "",
            "            if (dist[vertex] + c_w < dist[child])",
            "            {",
            "                par[child] = vertex;",
            "                dist[child] = dist[vertex] + c_w;",
            "                st.insert({dist[child], child});",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "DIJKSTRA"
    },
    "EXTENDED_EUCLIDEAN_ALGORITHM": {
        "prefix": "EXTENDED_EUCLIDEAN_ALGO",
        "body": [
            "int gcd(int x, int y)",
            "{",
            "    if (y == 0)",
            "        return x;",
            "    else",
            "        return gcd(y, x % y);",
            "}",
            "int Extended_Euclidean_Algorithm(int a, int b, int &x, int &y)",
            "{",
            "    if (b == 0)",
            "    {",
            "        x = 1;",
            "        y = 0;",
            "        return a;",
            "    }",
            "    int x1, y1;",
            "    int d = Extended_Euclidean_Algorithm(b, a % b, x1, y1);",
            "    x = y1;",
            "    y = x1 - y1 * (a / b);",
            "    return d;",
            "}",
            "int inverse(int a, int m)",
            "{",
            "    int x, y;",
            "    int g = Extended_Euclidean_Algorithm(a, m, x, y);",
            "    if (g != 1)",
            "        return -1;",
            "    return (x % m + m) % m;",
            "}",
            "bool asolution(int a, int b, int c, int &x, int &y)",
            "{",
            "    int d = gcd(a, b);",
            "    if (c % d != 0)",
            "        return false;",
            "    a /= d, b /= d, c /= d;",
            "    int ain = inverse(a, b);",
            "    x = (c * ain) % b;",
            "    y = (c - a * x) / b;",
            "    return true;",
            "}",
            "bool find_any_solution(int a, int b, int c, int &x0, int &y0)",
            "{",
            "    int g = Extended_Euclidean_Algorithm(abs(a), abs(b), x0, y0);",
            "    if (c % g)",
            "    {",
            "        return false;",
            "    }",
            "",
            "    x0 *= c / g;",
            "    y0 *= c / g;",
            "    if (a < 0)",
            "        x0 = -x0;",
            "    if (b < 0)",
            "        y0 = -y0;",
            "    return true;",
            "}"
        ],
        "description": "EXTENDED_EUCLIDEAN_ALGORITHM"
    },
    "floyd_warshall": {
        "prefix": "FLOYD_WARSHALL",
        "body": [
            " for (int k = 0; k < n; ++k)",
            "    {",
            "        for (int i = 0; i < n; ++i)",
            "        {",
            "            for (int j = 0; j < n; ++j)",
            "            {",
            "                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);",
            "            }",
            "        }",
            "    }",
            "",
            "    for (int i = 0; i < n; ++i)",
            "    {",
            "        for (int j = 0; j < n; ++j)",
            "        {",
            "            for (int t = 0; t < n; ++t)",
            "            {",
            "                if (dp[i][t] < INF && dp[t][t] < 0 && dp[t][j] < INF)",
            "                    dp[i][j] = -INF;",
            "            }",
            "        }",
            "    }"
        ],
        "description": "floyd_warshall"
    },
    "hashing": {
        "prefix": "HASHING",
        "body": [
            "const int N = 1e6 + 9;",
            "",
            "int power(long long n, long long k, const int mod) {",
            "  int ans = 1 % mod;",
            "  n %= mod;",
            "  if (n < 0) n += mod;",
            "  while (k) {",
            "    if (k & 1) ans = (long long) ans * n % mod;",
            "    n = (long long) n * n % mod;",
            "    k >>= 1;",
            "  }",
            "  return ans;",
            "}",
            "",
            "const int MOD1 = 127657753, MOD2 = 987654319;",
            "const int p1 = 137, p2 = 277;",
            "int ip1, ip2;",
            "pair<int, int> pw[N], ipw[N];",
            "void prec() {",
            "  pw[0] =  {1, 1};",
            "  for (int i = 1; i < N; i++) {",
            "    pw[i].first = 1LL * pw[i - 1].first * p1 % MOD1;",
            "    pw[i].second = 1LL * pw[i - 1].second * p2 % MOD2;",
            "  }",
            "  ip1 = power(p1, MOD1 - 2, MOD1);",
            "  ip2 = power(p2, MOD2 - 2, MOD2);",
            "  ipw[0] =  {1, 1};",
            "  for (int i = 1; i < N; i++) {",
            "    ipw[i].first = 1LL * ipw[i - 1].first * ip1 % MOD1;",
            "    ipw[i].second = 1LL * ipw[i - 1].second * ip2 % MOD2;",
            "  }",
            "",
            "}",
            "struct Hashing {",
            "  int n;",
            "  string s; // 0 - indexed",
            "  vector<pair<int, int>> hs; // 1 - indexed",
            "  Hashing() {}",
            "  Hashing(string _s) {",
            "    n = _s.size();",
            "    s = _s;",
            "    hs.emplace_back(0, 0);",
            "    for (int i = 0; i < n; i++) {",
            "      pair<int, int> p;",
            "      p.first = (hs[i].first + 1LL * pw[i].first * s[i] % MOD1) % MOD1;",
            "      p.second = (hs[i].second + 1LL * pw[i].second * s[i] % MOD2) % MOD2;",
            "      hs.push_back(p);",
            "    }",
            "  }",
            "  pair<int, int> get_hash(int l, int r) { // 1 - indexed",
            "    assert(1 <= l && l <= r && r <= n);",
            "    pair<int, int> ans;",
            "    ans.first = (hs[r].first - hs[l - 1].first + MOD1) * 1LL * ipw[l - 1].first % MOD1;",
            "    ans.second = (hs[r].second - hs[l - 1].second + MOD2) * 1LL * ipw[l - 1].second % MOD2;",
            "    return ans;",
            "  }",
            "  pair<int, int> get_hash() {",
            "    return get_hash(1, n);",
            "  }",
            "};"
        ],
        "description": "hashing"
    },
    "LCA": {
        "prefix": "LCA",
        "body": [
            "const int N = 2e5 + 9, LG = 18;",
            "vector<int> adj[N];",
            "int par[N][LG + 1], dep[N], sz[N];",
            "void dfs(int vertex, int p = 0)",
            "{",
            "    par[vertex][0] = p;",
            "    dep[vertex] = dep[p] + 1;",
            "    sz[vertex] = 1;",
            "    for (int i = 1; i <= LG; i++)",
            "        par[vertex][i] = par[par[vertex][i - 1]][i - 1];",
            "    for (auto child : adj[vertex])",
            "        if (child != p)",
            "        {",
            "            dfs(child, vertex);",
            "            sz[vertex] += sz[child];",
            "        }",
            "}",
            "int lca(int u, int v)",
            "{",
            "    if (dep[u] < dep[v])",
            "        swap(u, v);",
            "    for (int k = LG; k >= 0; k--)",
            "        if (dep[par[u][k]] >= dep[v])",
            "            u = par[u][k];",
            "    if (u == v)",
            "        return u;",
            "    for (int k = LG; k >= 0; k--)",
            "        if (par[u][k] != par[v][k])",
            "            u = par[u][k], v = par[v][k];",
            "    return par[u][0];",
            "}",
            "int kth(int u, int k)",
            "{",
            "    assert(k >= 0);",
            "    for (int i = 0; i <= LG; i++)",
            "        if (k & (1 << i))",
            "            u = par[u][i];",
            "    return u;",
            "}",
            "int dist(int u, int v)",
            "{",
            "    int l = lca(u, v);",
            "    return dep[u] + dep[v] - (dep[l] << 1);",
            "}",
            "// kth node from u to v, 0th node is u",
            "int go(int u, int v, int k)",
            "{",
            "    int l = lca(u, v);",
            "    int d = dep[u] + dep[v] - (dep[l] << 1);",
            "    assert(k <= d);",
            "    if (dep[l] + k <= dep[u])",
            "        return kth(u, k);",
            "    k -= dep[u] - dep[l];",
            "    return kth(v, dep[v] - dep[l] - k);",
            "}"
        ],
        "description": "LCA"
    },
    "MANACHER": {
        "prefix": "MANCHER",
        "body": [
            "vector<int> manacher_odd(string s)",
            "{",
            "    int n = s.size();",
            "    s = \"$\" + s + \"^\";",
            "    vector<int> p(n + 2);",
            "    int l = 1, r = 1;",
            "    for (int i = 1; i <= n; i++)",
            "    {",
            "        p[i] = max(0, min(r - i, p[l + (r - i)]));",
            "        while (s[i - p[i]] == s[i + p[i]])",
            "        {",
            "            p[i]++;",
            "        }",
            "        if (i + p[i] > r)",
            "        {",
            "            l = i - p[i], r = i + p[i];",
            "        }",
            "    }",
            "    return vector<int>(begin(p) + 1, end(p) - 1);",
            "}",
            "pair<vector<int>, vector<int>> manacher(string s)",
            "{",
            "    string t;",
            "    for (auto c : s)",
            "    {",
            "        t += string(\"#\") + c;",
            "    }",
            "    auto res = manacher_odd(t + \"#\");",
            "    res = vector<int>(begin(res) + 1, end(res) - 1);",
            "    vector<int> odd(s.size()), even(s.size());",
            "    for (int i = 0; i < (int)s.size(); i++)",
            "    {",
            "        odd[i] = res[2 * i] / 2;",
            "        if (i)",
            "        {",
            "            even[i] = (res[2 * i - 1] - 1) / 2;",
            "        }",
            "    }",
            "    return {odd, even};",
            "}"
        ],
        "description": "MANACHER"
    },
    "MATRIX": {
        "prefix": "MATRIXEXPO",
        "body": [
            "#include <bits/stdc++.h>",
            "#define ll long long int",
            "using namespace std;",
            "",
            "const int MOD = 1e9 + 7;",
            "",
            "struct matrix",
            "{",
            "    long long mat[2][2];",
            "",
            "    matrix operator+(const matrix &b) const",
            "    {",
            "        matrix c;",
            "        for (int i = 0; i < 2; ++i)",
            "            for (int j = 0; j < 2; ++j)",
            "                c.mat[i][j] = (mat[i][j] + b.mat[i][j]) % MOD;",
            "        return c;",
            "    }",
            "",
            "    matrix operator*(const matrix &b) const",
            "    {",
            "        matrix c;",
            "        for (int i = 0; i < 2; ++i)",
            "            for (int j = 0; j < 2; ++j)",
            "            {",
            "                c.mat[i][j] = 0;",
            "                for (int k = 0; k < 2; ++k)",
            "                    c.mat[i][j] = (c.mat[i][j] + mat[i][k] * b.mat[k][j]) % MOD;",
            "            }",
            "        return c;",
            "    }",
            "};",
            "matrix base, unit;",
            "",
            "bool isUnit(matrix &a)",
            "{",
            "    return a.mat[0][0] == 1 and a.mat[1][0] == 0 and a.mat[0][1] == 0 and a.mat[1][1] == 1;",
            "}",
            "",
            "matrix power(matrix a, long long e)",
            "{",
            "    e %= (MOD - 1);",
            "    matrix res = unit;",
            "",
            "    while (e)",
            "    {",
            "        if (e & 1)",
            "            res = res * a;",
            "        a = a * a;",
            "        e >>= 1;",
            "    }",
            "",
            "    return res;",
            "}",
            "int main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    unit.mat[0][0] = unit.mat[1][1] = 1, unit.mat[0][1] = unit.mat[1][0] = 0;",
            "    base.mat[0][0] = base.mat[0][1] = base.mat[1][0] = 1, base.mat[1][1] = 0;",
            "    auto result = power(base, 10);",
            "    cout << result.mat[0][0]<<\" \"<<result.mat[0][1] << endl;",
            "    cout << result.mat[1][0]<<\" \"<<result.mat[1][1] << endl;",
            "",
            "    return 0;",
            "}"
        ],
        "description": "MATRIX"
    },
    "COPRIME": {
        "prefix": "COPRIME",
        "body": [
            "const int N = 1e5 + 10;",
            "int phi[N];",
            "void totient()",
            "{",
            "    for (int i = 1; i < N; i++)",
            "        phi[i] = i;",
            "    for (int i = 2; i < N; i++)",
            "    {",
            "        if (phi[i] == i)",
            "        {",
            "            for (int j = i; j < N; j += i)",
            "                phi[j] -= phi[j] / i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "COPRIME"
    },
    "GETFACTOR": {
        "prefix": "GETFACTOR",
        "body": [
            "vector<int64_t> get_factors(const vector<pair<int64_t, int>> &pf)",
            "{",
            "    vector<int64_t> res;",
            "",
            "    function<void(int64_t, int)> dfs = [&](int64_t yet, int i)",
            "    {",
            "        if (i == (int)pf.size())",
            "        {",
            "            res.push_back(yet);",
            "            return;",
            "        }",
            "        for (int x = 0; x <= pf[i].second; x++)",
            "        {",
            "            dfs(yet, i + 1);",
            "            yet *= pf[i].first;",
            "        }",
            "    };",
            "    dfs(1, 0);",
            "    sort(res.begin(), res.end());",
            "    return res;",
            "}",
            "vector<int64_t> get_factors(int64_t x)",
            "{",
            "    return get_factors(prime_factorize(x));",
            "}"
        ],
        "description": "GETFACTOR"
    },
    "PRIMEFACTOR": {
        "prefix": "PRIMEFACTOR",
        "body": [
            "vector<pair<int64_t, int>> prime_factorize(int64_t n)",
            "{",
            "    vector<pair<int64_t, int>> result;",
            "    for (auto i : primes)",
            "    {",
            "        int cnt = 0;",
            "        while (n % i == 0)",
            "        {",
            "            n /= i;",
            "            cnt++;",
            "        }",
            "        if (cnt)",
            "        {",
            "            result.emplace_back(i, cnt);",
            "        }",
            "    }",
            "    if (n > 1)",
            "        result.emplace_back(n, 1);",
            "    return result;",
            "}"
        ],
        "description": "PRIMEFACTOR"
    },
    "SIEVE": {
        "prefix": "SIEVE",
        "body": [
            "vector<int> smallest_factor;",
            "vector<bool> prime;",
            "vector<int> primes;",
            "void sieve(ll maximum)",
            "{",
            "    maximum = max(maximum, 1ll);",
            "    smallest_factor.assign(maximum + 1, 0);",
            "    prime.assign(maximum + 1, true);",
            "    prime[0] = prime[1] = false;",
            "    primes = {};",
            "    for (int p = 2; p <= maximum; p++)",
            "    {",
            "        if (prime[p])",
            "        {",
            "            smallest_factor[p] = p;",
            "            primes.push_back(p);",
            "            for (int64_t i = (int64_t)(p)*p; i <= maximum; i += p)",
            "            {",
            "                if (prime[i])",
            "                {",
            "                    prime[i] = false;",
            "                    smallest_factor[i] = p;",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
            ""
        ],
        "description": "SIEVE"
    },
    "GRIDMOVES": {
        "prefix": "GRIDMOVES",
        "body": [
            "/*----------------------Graph Moves----------------*/",
            "// const int fx[]={+1,-1,+0,+0};",
            "// const int fy[]={+0,+0,+1,-1};",
            "// const int fx[]={+0,+0,+1,-1,-1,+1,-1,+1};   // Kings Move",
            "// const int fy[]={-1,+1,+0,+0,+1,+1,-1,-1};  // Kings Move",
            "// const int fx[]={-2, -2, -1, -1,  1,  1,  2,  2};  // Knights Move",
            "// const int fy[]={-1,  1, -2,  2, -2,  2, -1,  1}; // Knights Move",
            "/*------------------------------------------------*/"
        ],
        "description": "GRIDMOVES"
    },
    "MST": {
        "prefix": "MST",
        "body": [
            "vector<tuple<int, int, int>> edg;",
            "int n, m;",
            "int MST()",
            "{",
            "    DSU g(n);",
            "    sort(edg.begin(), edg.end());",
            "    int totcost = 0;",
            "    for (auto [w, u, v] : edg)",
            "    {",
            "        if (g.find_set(u) == g.find_set(v))",
            "            continue;",
            "        totcost += w;",
            "        g.marge(u, v);",
            "    }",
            "",
            "    return totcost;",
            "}"
        ],
        "description": "MST"
    },
    "NCRMOD": {
        "prefix": "NCRMOD",
        "body": [
            "const int M = 1e9 + 7, N = 200000 + 5;",
            "ll fact[N], invfact[N];",
            "ll bigmod(ll a, ll b)",
            "{",
            "    a %= M;",
            "    long long res = 1;",
            "    while (b > 0)",
            "    {",
            "        if (b & 1)",
            "            res = res * a % M;",
            "        a = a * a % M;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            "void factorialcul()",
            "{",
            "    fact[0] = 1;",
            "    for (int i = 1; i < N; i++)",
            "    {",
            "        fact[i] = ((fact[i - 1] % M) * (i % M)) % M;",
            "    }",
            "    invfact[N - 1] = bigmod(fact[N - 1], M - 2);",
            "    for (int i = N - 2; i >= 0; --i)",
            "    {",
            "        invfact[i] = ((invfact[i + 1] % M) * (i + 1)) % M;",
            "    }",
            "}",
            "ll ncr(ll n, ll r)",
            "{",
            "    if (r > n)",
            "        return 0ll;",
            "    ll res = fact[n] % M;",
            "    res = res * (invfact[n - r] % M);",
            "    res %= M;",
            "    res = res * (invfact[r] % M);",
            "    res %= M;",
            "    return res;",
            "}"
        ],
        "description": "NCRMOD"
    },
    "SPARCETABLE": {
        "prefix": "SPARCETABLE",
        "body": [
            "const int N = 2e6 + 5;",
            "const int LOGN = 22;",
            "",
            "int st[N][LOGN];",
            "",
            "",
            "int get(int L, int R)",
            "{",
            "    int d = 31 - __builtin_clz(R - L);",
            "",
            "    return max(st[L][d], st[R - (1 << d)][d]);",
            "}",
            "void build(vector<int> &v)",
            "{",
            "    int n = v.size();",
            "",
            "    // v index 0 base",
            "    for (int i = 0; i < n; i++)",
            "        st[i][0] = v[i];",
            "",
            "    for (int j = 1; j < LOGN; j++)",
            "        for (int i = 0; i + (1 << j) <= n; i++)",
            "            st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);",
            "}"
        ],
        "description": "SPARCETABLE"
    },
    "modcalculation": {
        "prefix": "modcal",
        "body": [
            "const int mod = 1e9 + 7;",
            "long long power(long long a, long long b)",
            "{",
            "    long long x = 1;",
            "    while (b)",
            "    {",
            "        if (b & 1)",
            "            x = x * a % mod;",
            "        a = a * a % mod;",
            "        b >>= 1;",
            "    }",
            "    return x;",
            "}",
            "long long addmod(long long a, long long b)",
            "{",
            "    long long ans = (a % mod + b % mod) % mod;",
            "    return ans;",
            "}",
            "long long submod(long long a, long long b)",
            "{",
            "    long long ans = (a % mod - b % mod + mod) % mod;",
            "    return ans;",
            "}",
            "long long mulmod(long long a, long long b)",
            "{",
            "    long long ans = ((a % mod) * (b % mod)) % mod;",
            "    return ans;",
            "}"
        ],
        "description": "modcalculation"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "struct FenwickTree",
            "{",
            "    vector<int> bit; // binary indexed tree",
            "    int n;",
            "",
            "    FenwickTree(int n)",
            "    {",
            "        this->n = n;",
            "        bit.assign(n, 0);",
            "    }",
            "",
            "    FenwickTree(vector<int> const &a) : FenwickTree(a.size())",
            "    {",
            "        for (size_t i = 0; i < a.size(); i++)",
            "            add(i, a[i]);",
            "    }",
            "",
            "    int sum(int r)",
            "    {",
            "        int ret = 0;",
            "        for (; r >= 0; r = (r & (r + 1)) - 1)",
            "            ret += bit[r];",
            "        return ret;",
            "    }",
            "",
            "    int sum(int l, int r)",
            "    {",
            "        return sum(r) - sum(l - 1);",
            "    }",
            "",
            "    void add(int idx, int delta)",
            "    {",
            "        for (; idx < n; idx = idx | (idx + 1))",
            "            bit[idx] += delta;",
            "    }",
            "",
            "    void add(int l, int r, int val)",
            "    {",
            "        add(l, val);",
            "        add(r + 1, -val);",
            "    }",
            "};"
        ],
        "description": "BIT"
    },
    "fileinputoutput": {
        "prefix": "FILEINOUT",
        "body": [
            " freopen(\"input.txt\", \"r\", stdin);",
            " freopen(\"output.txt\", \"w\", stdout);"
        ],
        "description": "fileinputoutput"
    },
    "Gridvalid": {
        "prefix": "Gridvalid",
        "body": [
            "int dx[] = {-1, 0, 1, 0};",
            "int dy[] = {0, -1, 0, 1};",
            "bool isvalid(int x, int y,int n,int m)",
            "{",
            "    if (x < 1 || y < 1 || x > n || y > m)",
            "        return false;",
            "    return true;",
            "}"
        ],
        "description": "Gridvalid"
    },
    "Segmenttree": {
        "prefix": "SEGMENTTREE",
        "body": [
            "class SegTree",
            "{",
            "public:",
            "    struct Node",
            "    {",
            "       //need change",
            "    };",
            "",
            "    vector<Node> seg;",
            "    SegTree(int n)",
            "    {",
            "        seg.resize(4 * n + 1);",
            "    }",
            "    void BuildTree(int ind, int low, int high, vector<ll> &v)",
            "    {",
            "        if (low == high)",
            "        {",
            "            auto &c = seg[ind];",
            "            //need change",
            "            return;",
            "        }",
            "        int mid = (low + high) >> 1;",
            "        BuildTree(2 * ind + 1, low, mid, v);",
            "        BuildTree(2 * ind + 2, mid + 1, high, v);",
            "        seg[ind] = marge(seg[2 * ind + 1], seg[2 * ind + 2]);",
            "    }",
            "    Node QuerySeg(int ind, int low, int high, int l, int r)",
            "    {",
            "        if (low > r or high < l)",
            "        {",
            "            Node tem;//need change",
            "            return tem;",
            "        }",
            "        if (low >= l and r >= high)",
            "        {",
            "            return seg[ind];",
            "        }",
            "        int mid = (low + high) >> 1;",
            "        auto left = QuerySeg(2 * ind + 1, low, mid, l, r);",
            "        auto right = QuerySeg(2 * ind + 2, mid + 1, high, l, r);",
            "        return marge(left, right);",
            "    }",
            "    void Updateseg(int ind, int low, int high, int x, ll val)",
            "    {",
            "",
            "        if (low == high)",
            "        {",
            "            auto &c = seg[ind];",
            "            //need change",
            "            return;",
            "        }",
            "        int mid = (low + high) >> 1;",
            "        if (x <= mid)",
            "            Updateseg(2 * ind + 1, low, mid, x, val);",
            "        else",
            "            Updateseg(2 * ind + 2, mid + 1, high, x, val);",
            "",
            "        seg[ind] = marge(seg[2 * ind + 1], seg[2 * ind + 2]);",
            "    }",
            "    Node marge(Node &a, Node &b)",
            "    {",
            "        auto ans = a;",
            "        //need change ",
            "",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Segmenttree"
    },
    "Template": {
        "prefix": "TEMPLATE",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "void test_case() {",
            "  $0",
            "}",
            "",
            "int main() {",
            "  ios::sync_with_stdio(false);",
            "  cin.tie(nullptr);",
            "",
            "  int t = 1;",
            "  $1cin >> t;",
            "",
            "  for (int cs = 1; cs <= t; cs++) {",
            "    // cout << \"Case $2\" << cs << \": \";",
            "    test_case();",
            "  }",
            "",
            "  return 0;",
            "}"
        ],
        "description": "Template"
    },
    "Vector Bounds": {
        "prefix": "VECTORBOUNDS",
        "body": [
            "template <typename T>",
            "int lb(const vector<T> &v, const T &a) {",
            "  return lower_bound(begin(v), end(v), a) - begin(v);",
            "}",
            "template <typename T>",
            "int ub(const vector<T> &v, const T &a) {",
            "  return upper_bound(begin(v), end(v), a) - begin(v);",
            "}"
        ],
        "description": "Vector Bounds"
    },
    "Generator (Testlib)": {
        "prefix": "GENERATOR",
        "body": [
            "#include \"testlib.h\"",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "int main(int argc, char *argv[]) {",
            "  registerGen(argc, argv, 1);",
            "  ios::sync_with_stdio(false);",
            "  cin.tie(0);",
            "",
            "  /*",
            "   * First command line argument",
            "   */",
            "  {",
            "    int n = opt<int>(1);",
            "  }",
            "",
            "  /*",
            "   * Uniformly distributed random number in the range [0, r) or [l, r]",
            "   */",
            "  {",
            "    int l = opt<int>(1);",
            "    int r = opt<int>(2);",
            "    rnd.next(r);",
            "    rnd.next(l, r);",
            "  }",
            "",
            "  /* Weighted distributed random number in the range [l, r].",
            "   * Max/min (depending on whether w is positive/negative) over |w|+1 iterations of rnd.next(l, r).",
            "   */",
            "  {",
            "    int l = opt<int>(1);",
            "    int r = opt<int>(2);",
            "    int w = opt<int>(3);",
            "    rnd.wnext(l, r, w);",
            "  }",
            "",
            "  /*",
            "   * Random word of (weighted) length[1, 1000]",
            "   */",
            "  {",
            "    rnd.next(\"[a-zA-Z0-9]{1,1000}\");",
            "    int length = rnd.wnext(1, 1000, opt<int>(1));",
            "    rnd.next(\"[a-zA-Z0-9]{1,%d}\", length);",
            "  }",
            "",
            "  /*",
            "   * Outputs random 100-digits binary string mostly containing 0's.",
            "   * In average it contains only 10% of 1's.",
            "   */",
            "  {",
            "    rnd.next(\"[0000000001]{100}\");",
            "  }",
            "",
            "  /*",
            "   * Random permutation of numbers [first, first + size)",
            "   */",
            "  {",
            "    int size = opt<int>(1);",
            "    int first = opt<int>(2);",
            "    rnd.perm(size, first);",
            "  }",
            "",
            "  /*",
            "   * Shuffle v",
            "   */",
            "  {",
            "    vector<int> v = rnd.perm(10, 1);",
            "    shuffle(v.begin(), v.end());",
            "  }",
            "",
            "  /*",
            "   * Returns size unordered distinct numbers between [0, r) or [l, r]",
            "   */",
            "  {",
            "    int size = opt<int>(1);",
            "    int l = opt<int>(2);",
            "    int r = opt<int>(3);",
            "    rnd.distinct(size, r);",
            "    rnd.distinct(size, l, r);",
            "  }",
            "",
            "  /*",
            "   * Returns a partition of sum into size numbers each of which is at least min_part",
            "   */",
            "  {",
            "    int size = opt<int>(1);",
            "    int sum = opt<int>(2);",
            "    int min_part = 1;",
            "    rnd.partition(size, sum, min_part);",
            "  }",
            "",
            "  /*",
            "   * Returns (weighted) random element from container",
            "   */",
            "  {",
            "    set<int> st{1, 2, 5, 3};",
            "    rnd.any(vector<int>(begin(st), end(st)));",
            "    rnd.wany(vector<int>(begin(st), end(st)), 2);",
            "  }",
            "",
            "  /*",
            "   * Print in a single line",
            "   */",
            "  {",
            "    println(\"Hello World!!!\");",
            "  }",
            "",
            "  return 0;",
            "}"
        ],
        "description": "Generator (Testlib)"
    },
    "Generator (Jngen)": {
        "prefix": "GENERATOR",
        "body": [
            "#include \"jngen.h\"",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "int main(int argc, char *argv[]) {",
            "  registerGen(argc, argv);",
            "  parseArgs(argc, argv);",
            "",
            "  return 0;",
            "}"
        ],
        "description": "Generator (Jngen)"
    },
    "Geodeb": {
        "prefix": "GEODEB",
        "body": [
            "#include \"geodeb.h\"",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "int main() {",
            "  string file_path = __FILE__;",
            "  string dir_path = file_path.substr(0, file_path.rfind(\"/\"));",
            "  GD_INIT(dir_path + \"/geodeb.html\", \"/Users/drswad/Desktop/CP/Setup/Geodeb Client\");",
            "",
            "  /*",
            "     GD_POINT(x, y, attr);",
            "     GD_CIRCLE(x, y, r, attr);",
            "     GD_SEGMENT(x1, y1, x2, y2, attr);",
            "     GD_LINE(x1, y1, x2, y2, attr);",
            "     GD_TRIANGLE(x1, y1, x2, y2, x3, y3, attr);",
            "     GD_RECT(x1, y1, x2, y2, attr);",
            "     GD_ARC(x, y, r, start_angle, end_angle, attr);",
            "     GD_PIE(x, y, r, start_angle, end_angle, attr);",
            "     GD_PAUSE();",
            "     GD_LAYER();",
            "     GD_LAYER() << \"iteration = \" << i;",
            "     GD_POINT(best.x, best.y) << \"best score so far is \" << best_score;",
            "     GD_SET_PRECISION(digits);",
            "   */",
            "",
            "  return 0;",
            "}"
        ],
        "description": "Geodeb"
    },
    "Binary Exponentiation": {
        "prefix": "BINARYEXPONENTIATION",
        "body": [
            "ll binExp(ll a, ll e, ll m = MOD) {",
            "  if (e == -1) e = m - 2;",
            "  ll ret = 1;",
            "  while (e) {",
            "    if (e & 1) ret = ret * a % m;",
            "    a = a * a % m, e >>= 1;",
            "  }",
            "  return ret;",
            "}"
        ],
        "description": "O(log(e))"
    },
    "RMQ (Special)": {
        "prefix": "RMQ",
        "body": [
            "int n, a[N], tree[N << 1];",
            "",
            "// build",
            "void init() {",
            "  for (int i = 0; i < n; ++i) { tree[n + i] = a[i]; }",
            "  for (int i = n - 1; i >= 0; --i) {",
            "    tree[i] = min(tree[i << 1], tree[i << 1 | 1]); // modify",
            "  }",
            "}",
            "",
            "// assign a[p] = v",
            "void update(int p, int v) {",
            "  for (tree[p += n] = v; p > 1; p >>= 1) {",
            "    tree[p >> 1] = min(tree[p], tree[p ^ 1]); // modify",
            "  }",
            "}",
            "",
            "// range [l, r) sum",
            "int query(int l, int r) {",
            "  int ret = INT_MAX; // modify",
            "  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
            "    if (l & 1) ret = min(ret, tree[l++]); // modify",
            "    if (r & 1) ret = min(ret, tree[--r]); // modify",
            "  }",
            "  return ret;",
            "}"
        ],
        "description": "Special | Initialize O(n) | Update O(log(n)) | Query O(log(n))"
    },
    "RMQ (General)": {
        "prefix": "RMQ",
        "body": [
            "int n, a[N], tree[N << 2], lazy[N << 2];",
            "",
            "// build",
            "void init(int u = 1, int b = 1, int e = n) {",
            "  lazy[u] = 0; // modify",
            "  if (b == e) return void(tree[u] = a[b]);",
            "  int mid = b + e >> 1;",
            "  init(u << 1, b, mid), init(u << 1 | 1, mid + 1, e);",
            "  tree[u] = min(tree[u << 1], tree[u << 1 | 1]); // modify",
            "}",
            "",
            "// clear lazy value at node u",
            "inline void push(int u, int b, int e) {",
            "  tree[u] += lazy[u];                                               // modify",
            "  if (b != e) lazy[u << 1] += lazy[u], lazy[u << 1 | 1] += lazy[u]; // modify",
            "  lazy[u] = 0;                                                      // modify",
            "}",
            "",
            "// add v on range [l, r]",
            "void update(int l, int r, int v, int u = 1, int b = 1, int e = n) {",
            "  if (lazy[u]) push(u, b, e); // modify",
            "  if (b > r or e < l) return;",
            "  if (b >= l and e <= r) {",
            "    lazy[u] += v; // modify",
            "    return push(u, b, e);",
            "  }",
            "  int mid = b + e >> 1;",
            "  update(l, r, v, u << 1, b, mid), update(l, r, v, u << 1 | 1, mid + 1, e);",
            "  tree[u] = min(tree[u << 1], tree[u << 1 | 1]); // modify",
            "}",
            "",
            "// range [l, r] sum",
            "int query(int l, int r, int u = 1, int b = 1, int e = n) {",
            "  if (b > r or e < l) return INT_MAX; // modify",
            "  if (lazy[u]) push(u, b, e); // modify",
            "  if (b >= l and e <= r) return tree[u];",
            "  int mid = b + e >> 1;",
            "  return min(query(l, r, u << 1, b, mid),",
            "      query(l, r, u << 1 | 1, mid + 1, e)); // modify",
            "}",
            "",
            "// index of the rightmost zero",
            "int lastZero(int u = 1, int b = 1, int e = n) {",
            "  if (b == e) return b;",
            "  if (lazy[u]) push(u, b, e); // modify",
            "  int mid = b + e >> 1;",
            "  if (lazy[u << 1 | 1]) push(u << 1 | 1, mid + 1, e); // modify",
            "  if (tree[u << 1 | 1]) return lastZero(u << 1, b, mid);",
            "  return lastZero(u << 1 | 1, mid + 1, e);",
            "}"
        ],
        "description": "General | Initialize O(n) | Update O(log(n)) | Query O(log(n) | LastZero O(log(n))"
    },
    "Segment Tree (Special)": {
        "prefix": "SEGMENTTREE",
        "body": [
            "template<typename T, class F = function<T(const T&, const T&)>>",
            "class SegmentTree {",
            "  int n;",
            "  vector<T> a;",
            "  vector<T> st;",
            "  T st_default;",
            "  F merge;",
            "  F setval;",
            "  void build(int stI, int L, int R) {",
            "    if (L == R) {",
            "      st[stI] = a[L - 1];",
            "      return;",
            "    }",
            "",
            "    int mid = (L + R) >> 1;",
            "    build(stI << 1, L, mid);",
            "    build(stI << 1 | 1, mid + 1, R);",
            "",
            "    st[stI] = merge(st[stI << 1], st[stI << 1 | 1]);",
            "  }",
            "  void update(int stI, int L, int R, int at, T val) {",
            "    if (L == R) {",
            "      st[stI] = setval(st[stI], val);",
            "      return;",
            "    }",
            "",
            "    int mid = (L + R) >> 1;",
            "    if (at <= mid) update(stI << 1, L, mid, at, val);",
            "    else update(stI << 1 | 1, mid + 1, R, at, val);",
            "",
            "    st[stI] = merge(st[(stI << 1)], st[(stI << 1) + 1]);",
            "  }",
            "  T query(int stI, int L, int R, int l, int r) {",
            "    if (l <= L && R <= r) return st[stI];",
            "",
            "    int mid = (L + R) >> 1;",
            "    if (r <= mid) return query(stI << 1, L, mid, l, r);",
            "    else if (mid + 1 <= l) return query(stI << 1 | 1, mid + 1, R, l, r);",
            "    else return merge(",
            "        query(stI << 1, L, mid, l, mid),",
            "        query(stI << 1 | 1, mid + 1, R, mid + 1, r)",
            "        );",
            "  }",
            "public:",
            "  SegmentTree(const vector<T> &_a, const F &_merge, const F &_setval, T st_default, bool build_init) {",
            "    n = static_cast<int>(_a.size());",
            "    a = _a;",
            "    st.resize(4 * n + 1, st_default);",
            "    this->st_default = st_default;",
            "    merge = _merge;",
            "    setval = _setval;",
            "    if (build_init) build(1, 1, n);",
            "  }",
            "  T query(int l, int r) { // range [l, r], 1-based index",
            "    if (r < 1 || n < l || r < l) return st_default;",
            "    l = max(l, 1); r = min(r, n);",
            "    return query(1, 1, n, l, r);",
            "  }",
            "  void update(int at, T val) { // at is 1-based index",
            "    if (at < 1 || n < at) return;",
            "    update(1, 1, n, at, val);",
            "  }",
            "};",
            "// SegmentTree<long long> st(a, [&](long long i, long long j) {return i + j;}, [&](long long i, long long j) {return j;}, 0ll, true)"
        ],
        "description": "Special | Initialize O(n) | Update O(log(n)) | Query O(log(n))"
    },
    "Segment Tree (General)": {
        "prefix": "SEGMENTTREE",
        "body": [
            "template<typename T, class F = function<T(const T&, const T&)>>",
            "class SegmentTreeLazy {",
            "private:",
            "  int n;",
            "  vector<T> a;",
            "  vector<T> st, lz;",
            "  T st_default, lz_default;",
            "  F st_merge, lz_merge;",
            "",
            "  void build(int stI, int L, int R) {",
            "    if (L == R) return void(st[stI] = a[L - 1]);",
            "    int mid = (L + R) >> 1;",
            "    build(stI << 1, L, mid), build(stI << 1 | 1, mid + 1, R);",
            "    st[stI] = st_merge(st[stI << 1], st[stI << 1 | 1]);",
            "  }",
            "",
            "  inline void push(int stI, int L, int R) {",
            "    st[stI] = lz_merge(st[stI], lz[stI]);",
            "    if (L != R) {",
            "      lz[stI << 1] = lz_merge(lz[stI << 1], lz[stI]);",
            "      lz[stI << 1 | 1] = lz_merge(lz[stI << 1 | 1], lz[stI]);",
            "    }",
            "    lz[stI] = lz_default;",
            "  }",
            "",
            "  void update(int stI, int L, int R, int l, int r, T val) {",
            "    if (lz[stI] != lz_default) push(stI, L, R);",
            "    if (r < L or R < l) return;",
            "    if (l <= L && R <= r) {",
            "      lz[stI] = lz_merge(lz[stI], val);",
            "      return push(stI, L, R);",
            "    }",
            "    int mid = (L + R) >> 1;",
            "    update(stI << 1, L, mid, l, r, val);",
            "    update(stI << 1 | 1, mid + 1, R, l, r, val);",
            "    st[stI] = st_merge(st[stI << 1], st[stI << 1 | 1]);",
            "  }",
            "",
            "  T query(int stI, int L, int R, int l, int r) {",
            "    if (r < L or R < l) return st_default;",
            "    if (lz[stI] != lz_default) push(stI, L, R);",
            "    if (l <= L && R <= r) return st[stI];",
            "    int mid = (L + R) >> 1;",
            "    return st_merge(",
            "      query(stI << 1, L, mid, l, r),",
            "      query(stI << 1 | 1, mid + 1, R, l, r)",
            "      );",
            "  }",
            "",
            "public:",
            "  SegmentTreeLazy(const vector<T> &a, const F &st_merge, const F &lz_merge, T st_default, T lz_default, bool build_init) {",
            "    n = static_cast<int>(a.size());",
            "    this->a = a;",
            "    st.resize(4 * n + 1, st_default);",
            "    lz.resize(4 * n + 1, lz_default);",
            "    this->st_default = st_default;",
            "    this->lz_default = lz_default;",
            "    this->st_merge = st_merge;",
            "    this->lz_merge = lz_merge;",
            "    if (build_init) build(1, 1, n);",
            "  }",
            "  T query(int l, int r) { // range [l, r], 1-based index",
            "    if (r < 1 || n < l || r < l) return st_default;",
            "    l = max(l, 1); r = min(r, n);",
            "    return query(1, 1, n, l, r);",
            "  }",
            "  void update(int l, int r, T val) { // range [l, r], 1-based index",
            "    if (r < 1 || n < l || r < l) return;",
            "    l = max(l, 1); r = min(r, n);",
            "    update(1, 1, n, l, r, val);",
            "  }",
            "};",
            "/*",
            "   SegmentTreeLazy<long long> st(",
            "   a,",
            "   [&](long long i, long long j) {return i + j;}, // queries sum of the numbers in the range",
            "   [&](long long i, long long j) {return i * j;}, // multiplies range by a number in updates",
            "   0, // default value of array should be 0",
            "   1, // default value of lazy should be 1",
            "   true); // needs to build the tree on initialization, since provided vector has non-default values",
            " */"
        ],
        "description": "General | Initialize O(n) | Update O(log(n)) | Query O(log(n)"
    },
    "ExtGCD": {
        "prefix": "EXTGCD",
        "body": [
            "template <typename T>",
            "T extgcd(T a, T b, T &x, T &y) {",
            "  if (a == 0) {",
            "    x = 0;",
            "    y = 1;",
            "    return b;",
            "  }",
            "  T p = b / a;",
            "  T g = extgcd(b - p * a, a, y, x);",
            "  x -= p * y;",
            "  return g;",
            "}"
        ],
        "description": "O(log(min(a, b)))"
    },
    "Diophantine": {
        "prefix": "DIOPHANTINE",
        "body": [
            "template <typename T>",
            "bool diophantine(T a, T b, T c, T &x, T &y, T &g) {",
            "  if (a == 0 && b == 0) {",
            "    if (c == 0) {",
            "      x = y = g = 0;",
            "      return true;",
            "    }",
            "    return false;",
            "  }",
            "  if (a == 0) {",
            "    if (c % b == 0) {",
            "      x = 0;",
            "      y = c / b;",
            "      g = abs(b);",
            "      return true;",
            "    }",
            "    return false;",
            "  }",
            "  if (b == 0) {",
            "    if (c % a == 0) {",
            "      x = c / a;",
            "      y = 0;",
            "      g = abs(a);",
            "      return true;",
            "    }",
            "    return false;",
            "  }",
            "  g = extgcd(a, b, x, y);",
            "  if (c % g != 0) {",
            "    return false;",
            "  }",
            "  T dx = c / a;",
            "  c -= dx * a;",
            "  T dy = c / b;",
            "  c -= dy * b;",
            "  x = dx + (T)((__int128)x * (c / g) % b);",
            "  y = dy + (T)((__int128)y * (c / g) % a);",
            "  g = abs(g);",
            "  return true;",
            "  // |x|, |y| <= max(|a|, |b|, |c|) [tested]",
            "}"
        ],
        "description": "O(log(min(a, b)))"
    },
    "CRT": {
        "prefix": "CRT",
        "body": [
            "bool crt(long long k1, long long m1, long long k2, long long m2,",
            "    long long &k, long long &m) {",
            "  k1 %= m1;",
            "  if (k1 < 0)",
            "    k1 += m1;",
            "  k2 %= m2;",
            "  if (k2 < 0)",
            "    k2 += m2;",
            "  long long x, y, g;",
            "  if (!diophantine(m1, -m2, k2 - k1, x, y, g)) {",
            "    return false;",
            "  }",
            "  long long dx = m2 / g;",
            "  long long delta = x / dx - (x % dx < 0);",
            "  k = m1 * (x - dx * delta) + k1;",
            "  m = m1 / g * m2;",
            "  assert(0 <= k && k < m);",
            "  return true;",
            "}"
        ],
        "description": "O(log(min(m1, m2)))"
    },
    "Maximum Flow (Dinic)": {
        "prefix": "MAXIMUMFLOW",
        "body": [
            "struct edge {",
            "  int u, v;",
            "  ll cap, flow;",
            "  edge() {}",
            "  edge(int u, int v, ll cap) : u(u), v(v), cap(cap), flow(0) {}",
            "};",
            "",
            "struct Dinic {",
            "  int N;",
            "  vector<edge> E;",
            "  vector<vector<int>> g;",
            "  vector<int> d, pt;",
            "",
            "  Dinic(int N) : N(N), E(0), g(N), d(N), pt(N) {}",
            "",
            "  void AddEdge(int u, int v, ll cap) {",
            "    if (u ^ v) {",
            "      E.emplace_back(u, v, cap);",
            "      g[u].emplace_back(E.size() - 1);",
            "      E.emplace_back(v, u, 0);",
            "      g[v].emplace_back(E.size() - 1);",
            "    }",
            "  }",
            "",
            "  bool BFS(int S, int T) {",
            "    queue<int> q({S});",
            "    fill(d.begin(), d.end(), N + 1);",
            "    d[S] = 0;",
            "    while (!q.empty()) {",
            "      int u = q.front();",
            "      q.pop();",
            "      if (u == T) break;",
            "      for (int k : g[u]) {",
            "        edge &e = E[k];",
            "        if (e.flow < e.cap and d[e.v] > d[e.u] + 1) {",
            "          d[e.v] = d[e.u] + 1;",
            "          q.emplace(e.v);",
            "        }",
            "      }",
            "    }",
            "    return d[T] != N + 1;",
            "  }",
            "",
            "  ll DFS(int u, int T, ll flow = -1) {",
            "    if (u == T or flow == 0) return flow;",
            "    for (int &i = pt[u]; i < g[u].size(); ++i) {",
            "      edge &e = E[g[u][i]];",
            "      edge &oe = E[g[u][i] ^ 1];",
            "      if (d[e.v] == d[e.u] + 1) {",
            "        ll amt = e.cap - e.flow;",
            "        if (flow != -1 and amt > flow) amt = flow;",
            "        if (ll pushed = DFS(e.v, T, amt)) {",
            "          e.flow += pushed;",
            "          oe.flow -= pushed;",
            "          return pushed;",
            "        }",
            "      }",
            "    }",
            "    return 0;",
            "  }",
            "",
            "  ll MaxFlow(int S, int T) {",
            "    ll total = 0;",
            "    while (BFS(S, T)) {",
            "      fill(pt.begin(), pt.end(), 0);",
            "      while (ll flow = DFS(S, T)) total += flow;",
            "    }",
            "    return total;",
            "  }",
            "};",
            "/*",
            "Dinic dinic(N);",
            "dinic.AddEdge(u - 1, v - 1, cap);",
            "dinic.AddEdge(v - 1, u - 1, cap);",
            "dinic.MaxFlow(0, N - 1);",
            "*/"
        ],
        "description": "Dinic | O(V^2E)"
    },
    "Hopcroft Karp": {
        "prefix": "HOPCROFTKARP",
        "body": [
            "class HopcroftKarp {",
            "private:",
            "  const int INF = 1e8 + 5;",
            "  int n;",
            "  vector<vector<int>> g;",
            "  vector<int> match, dist;",
            "  bool bfs() {",
            "    queue<int> q;",
            "    for (int i = 1; i <= n; ++i) {",
            "      if (!match[i]) dist[i] = 0, q.emplace(i);",
            "      else dist[i] = INF;",
            "    }",
            "    dist[0] = INF;",
            "    while (!q.empty()) {",
            "      int u = q.front(); q.pop();",
            "      if (!u) continue;",
            "      for (int v : g[u - 1]) {",
            "        v++;",
            "        if (dist[match[v]] == INF) {",
            "          dist[match[v]] = dist[u] + 1,",
            "          q.emplace(match[v]);",
            "        }",
            "      }",
            "    }",
            "    return dist[0] != INF;",
            "  }",
            "  bool dfs(int u) {",
            "    if (!u) return true;",
            "    for (int v : g[u - 1]) {",
            "      v++;",
            "      if (dist[match[v]] == dist[u] + 1 and dfs(match[v])) {",
            "        match[u] = v, match[v] = u;",
            "        return true;",
            "      }",
            "    }",
            "    dist[u] = INF;",
            "    return false;",
            "  }",
            "public:",
            "  HopcroftKarp(vector<vector<int>> g) : n(g.size()), g(g) {",
            "    match.resize(n + 1, 0);",
            "    dist.resize(n + 1, 0);",
            "  }",
            "  pair<int, vector<int>> solve() {",
            "    int cnt = 0;",
            "    vector<int> match0(n);",
            "    while (bfs()) {",
            "      for (int i = 1; i <= n; ++i) {",
            "        cnt += !match[i] and dfs(i);",
            "      }",
            "    }",
            "    for (int i = 1; i <= n; i++) match0[i - 1] = match[i] - 1;",
            "    return {cnt, match0};",
            "  }",
            "};",
            "// HopcroftKarp(e).solve(); // e = 0-indexed adjacency-list",
            "// All the edges must be from one part to the other",
            "// Returns (max matching size, 0-indexed matches to each node from left part)"
        ],
        "description": "Hopcroft-Karp | O(E * sqrt(V))"
    },
    "Random Number Generator": {
        "prefix": "RANDOM",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "// const int BASE = uniform_int_distribution<int>(1, MOD - 1)(rng);",
            "// uniform_int_distribution<int> uid(low, high); // [low, high]",
            "// auto gen = bind(uid, rng);",
            "// shuffle(v.begin(), v.end(), rng)"
        ],
        "description": ""
    },
    "gp_hash_table": {
        "prefix": "GPHASHTABLE",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "using namespace __gnu_pbds;",
            "struct chash {",
            "  const int RANDOM = (long long)(make_unique<char>().get())",
            "      ^ chrono::high_resolution_clock::now()",
            "            .time_since_epoch()",
            "            .count();",
            "  static unsigned long long hash_f(unsigned long long x) {",
            "    x += 0x9e3779b97f4a7c15;",
            "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "    return x ^ (x >> 31);",
            "  }",
            "  static unsigned hash_combine(unsigned a, unsigned b) {",
            "    return a * 31 + b;",
            "  }",
            "  int operator()(int x) const { return hash_f(x) ^ RANDOM; }",
            "  int operator()(pair<int, int> x) const {",
            "    return hash_combine(x.first, x.second) ^ RANDOM;",
            "  }",
            "};",
            "// gp_hash_table<int, int, chash> mp;",
            "// gp_hash_table<ll, int, chash> mp;",
            "// gp_hash_table<pair<int, int>, int, chash> mp;"
        ],
        "description": ""
    },
    "Ordered Set": {
        "prefix": "ORDEREDSET",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "typedef tree<int, null_type, less<int>, rb_tree_tag,",
            "    tree_order_statistics_node_update>",
            "    ordered_set;",
            "// find_by_order(k) : iterator to the k'th element (0-indexed)",
            "// order_of_key(k) : number of items strictly smaller than k",
            "// auto cmp = [](int a, int b) { return a < b; };",
            "// tree<int, null_type, decltype(cmp)> x(cmp);",
            "// tree<int, null_type, function<bool(int, int)>> y(",
            "//     [](int a, int b) { return a < b; });"
        ],
        "description": ""
    },
    "Floor Sum Of AP": {
        "prefix": "FLOORSUMOFAP",
        "body": [
            "// Sum of floor((a * i + b) / c), 0 <= i <= n",
            "long long FloorSumAP(long long a, long long b, long long c, long long n) {",
            "  if (!a) return (b / c) * (n + 1);",
            "  if (a >= c or b >= c) return ((n * (n + 1)) / 2) * (a / c) + (n + 1) * (b / c) + FloorSumAP(a % c, b % c, c, n);",
            "  long long m = (a * n + b) / c;",
            "  return m * n - FloorSumAP(c, c - b - 1, a, m - 1);",
            "}"
        ],
        "description": "O(log(a))"
    },
    "Floor Sum of AP (Generalization 1)": {
        "prefix": "FLOORSUMOFAPGENERALIZED1",
        "body": [
            "// f = sum of floor((a * i + b) / c), 0 <= i <= n",
            "// g = sum of [floor((a * i + b) / c)]^2, 0 <= i <= n",
            "// h = sum of [i * floor((a * i + b) / c)], 0 <= i <= n",
            "typedef long long ll;",
            "const ll MOD = 998244353;",
            "const ll inv2 = 499122177;",
            "const ll inv6 = 166374059;",
            "",
            "struct dat {",
            "  ll f, g, h;",
            "};",
            "",
            "dat solve(ll a, ll b, ll c, ll n) {",
            "  if (!a) {",
            "    ll f = (n + 1) * (b / c) % MOD;",
            "    ll g = (n + 1) * (b / c) % MOD * (b / c) % MOD;",
            "    ll h = n * (n + 1) % MOD * inv2 % MOD * (b / c) % MOD;",
            "    return dat{(f + MOD) % MOD, (g + MOD) % MOD, (h + MOD) % MOD};",
            "  } else if (a >= c || b >= c) {",
            "    dat nxt = solve(a % c, b % c, c, n);",
            "    ll F = nxt.f + n * (n + 1) / 2 % MOD * (a / c) % MOD",
            "        + (n + 1) * (b / c) % MOD;",
            "    ll G = nxt.g + 2ll * (a / c) % MOD * nxt.h % MOD",
            "        + 2ll * (b / c) % MOD * nxt.f",
            "        + n % MOD * (n + 1) % MOD * (2ll * n % MOD + 1) % MOD * inv6",
            "            % MOD * (a / c) % MOD * (a / c) % MOD",
            "        + n % MOD * (n + 1) % MOD * (a / c) % MOD * (b / c) % MOD",
            "        + (n + 1) * (b / c) % MOD * (b / c) % MOD;",
            "    ll H = nxt.h",
            "        + n % MOD * (n + 1) % MOD * (2ll * n + 1) % MOD * inv6 % MOD",
            "            * (a / c) % MOD",
            "        + n % MOD * (n + 1) % MOD * inv2 % MOD * (b / c) % MOD;",
            "    return dat{(F + MOD) % MOD, (G + MOD) % MOD, (H + MOD) % MOD};",
            "  } else {",
            "    ll M = (a * n + b) / c;",
            "    dat nxt = solve(c, c - b - 1, a, M - 1);",
            "    ll F = n * M % MOD - nxt.f;",
            "    ll G = n * M % MOD * (M + 1) % MOD - 2ll * nxt.h % MOD + MOD",
            "        - 2ll * nxt.f % MOD + MOD - F % MOD;",
            "    ll H = (M * n % MOD * (n + 1) % MOD - nxt.g + MOD - nxt.f) % MOD",
            "        * inv2 % MOD;",
            "    return dat{(F + MOD) % MOD, (G + MOD) % MOD, (H + MOD) % MOD};",
            "  }",
            "}"
        ],
        "description": "O(3log(a))"
    },
    "Floor Sum of AP (Generalization 2)": {
        "prefix": "FLOORSUMOFAPGENERALIZED2",
        "body": [
            "// F(k1, k2, a, b, c, n) = sum of [i^k1 * floor((a * i + b) / c)^k2],",
            "// 0 <= i <= n",
            "typedef long long ll;",
            "const ll MOD = 1e9 + 7;",
            "const int N = 20;",
            "",
            "ll ncr[N][N], S[N][N], B[N], d[N][N];",
            "ll fact[N], inv[N];",
            "ll bigMod(ll a, ll p) {",
            "  ll ret = 1LL;",
            "  while (p) {",
            "    if (p & 1) { ret = (ret * a) % MOD; }",
            "    a = (a * a) % MOD;",
            "    p >>= 1LL;",
            "  }",
            "  return ret;",
            "}",
            "",
            "ll powerSum(ll n, ll k) {",
            "  ll ret = 0LL;",
            "  for (int i = 0; i <= k + 1; ++i) {",
            "    ret += d[k][i] * bigMod(n, i);",
            "    ret %= MOD;",
            "  }",
            "  return ret;",
            "}",
            "",
            "void init() {",
            "  fact[0] = 1;",
            "  for (int i = 1; i < N; ++i) { fact[i] = (fact[i - 1] * i) % MOD; }",
            "",
            "  inv[1] = 1;",
            "  for (int i = 2; i < N; ++i) {",
            "    inv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD;",
            "  }",
            "",
            "  S[0][0] = 1;",
            "  for (int i = 1; i < N; ++i) {",
            "    S[i][0] = 0;",
            "    for (int j = 1; j <= i; ++j) {",
            "      S[i][j] = j * S[i - 1][j] + S[i - 1][j - 1];",
            "      S[i][j] %= MOD;",
            "    }",
            "  }",
            "  for (int i = 1; i < N; ++i) {",
            "    ncr[i][0] = ncr[i][i] = 1;",
            "    for (int j = 1; j < i; ++j) {",
            "      ncr[i][j] = ncr[i - 1][j] + ncr[i - 1][j - 1];",
            "      ncr[i][j] %= MOD;",
            "    }",
            "  }",
            "  for (int i = 0; i < 15; ++i) {",
            "    for (int j = 0; j <= i; ++j) {",
            "      B[i] += ((j & 1) ? -1 : 1) * ((fact[j] * S[i][j]) % MOD)",
            "          * inv[j + 1];",
            "      B[i] %= MOD;",
            "    }",
            "  }",
            "  for (int i = 0; i < 15; ++i) {",
            "    for (int j = 0; j <= i; ++j) {",
            "      d[i][i + 1 - j] = (ncr[i + 1][j] * abs(B[j])) % MOD;",
            "      d[i][i + 1 - j] *= inv[i + 1];",
            "      d[i][i + 1 - j] %= MOD;",
            "    }",
            "  }",
            "  d[0][0] = 1; // 0^0 = 1",
            "}",
            "",
            "struct dat {",
            "  ll F[11][11];",
            "};",
            "",
            "dat F(ll k1, ll k2, ll a, ll b, ll c, ll n) {",
            "  if (!a) {",
            "    dat ret;",
            "    for (int _k1 = 0; _k1 <= k1 + k2; ++_k1) {",
            "      ret.F[_k1][0] = powerSum(n, _k1);",
            "      for (int _k2 = 1; _k1 + _k2 <= k1 + k2; ++_k2) {",
            "        ret.F[_k1][_k2] = (ret.F[_k1][0] * bigMod(b / c, _k2)) % MOD;",
            "      }",
            "    }",
            "    return ret;",
            "  }",
            "",
            "  dat ret;",
            "",
            "  if (a >= c) {",
            "    dat nxt = F(k1, k2, a % c, b, c, n);",
            "    for (int _k1 = 0; _k1 <= k1 + k2; ++_k1) {",
            "      ret.F[_k1][0] = powerSum(n, _k1);",
            "      for (int _k2 = 1; _k1 + _k2 <= k1 + k2; ++_k2) {",
            "        ret.F[_k1][_k2] = 0;",
            "        for (int y = 0; y <= _k2; ++y) {",
            "          ret.F[_k1][_k2] += ((ncr[_k2][y] * bigMod(a / c, y)) % MOD)",
            "              * nxt.F[_k1 + y][_k2 - y];",
            "          ret.F[_k1][_k2] %= MOD;",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  else if (b >= c) {",
            "    dat nxt = F(k1, k2, a, b % c, c, n);",
            "    for (int _k1 = 0; _k1 <= k1 + k2; ++_k1) {",
            "      ret.F[_k1][0] = powerSum(n, _k1);",
            "      for (int _k2 = 1; _k1 + _k2 <= k1 + k2; ++_k2) {",
            "        ret.F[_k1][_k2] = 0;",
            "        for (int y = 0; y <= _k2; ++y) {",
            "          ret.F[_k1][_k2] += ((ncr[_k2][y] * bigMod(b / c, y)) % MOD)",
            "              * nxt.F[_k1][_k2 - y];",
            "          ret.F[_k1][_k2] %= MOD;",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  else {",
            "    ll m = (a * n + b) / c;",
            "    dat nxt = F(k1, k2, c, c - b - 1, a, m - 1);",
            "    std::vector<ll> psumM(k1 + k2 + 1), pre(k1 + k2 + 1);",
            "    for (int i = 0; i <= k1 + k2; ++i)",
            "      psumM[i] = powerSum(m - 1, i); // precalculating power sum",
            "    for (int _k1 = 0; _k1 <= k1 + k2; ++_k1) {",
            "      for (int i = 0; i <= k1 + k2; ++i) {",
            "        pre[i] = 0;",
            "        for (int j = 0; j <= _k1 + 1; ++j) {",
            "          pre[i] += (d[_k1][j] * nxt.F[i][j]) % MOD;",
            "          pre[i] %= MOD;",
            "        }",
            "      }",
            "      ret.F[_k1][0] = powerSum(n, _k1);",
            "      for (int _k2 = 1; _k1 + _k2 <= k1 + k2; ++_k2) {",
            "        ret.F[_k1][_k2] = 0;",
            "        for (int i = 0; i < _k2; ++i) {",
            "          ret.F[_k1][_k2] +=",
            "              ((ncr[_k2][i] * psumM[i]) % MOD) * ret.F[_k1][0];",
            "          ret.F[_k1][_k2] -= ncr[_k2][i] * pre[i];",
            "          ret.F[_k1][_k2] %= MOD;",
            "        }",
            "      }",
            "    }",
            "  }",
            "  return ret;",
            "}",
            "// dat ans = F(k1, k2, a, b, c, n);",
            "// if (ans.F[k1][k2] < 0) { ans.F[k1][k2] += MOD; }",
            "// printf(\"%lld\\n\", ans.F[k1][k2]);"
        ],
        "description": "O((k1 + k2)^3 * log(a))"
    },
    "Stirling": {
        "prefix": "STIRLING",
        "body": [
            "ll stirling(ll n, ll k) {",
            "  if (k == n) {",
            "    return 1;",
            "  }",
            "  if (k == 0) {",
            "    return 0;",
            "  }",
            "  if (n < k) {",
            "    return 1;",
            "  }",
            "",
            "  ll ret = 0;",
            "  for (int i = 0, p = 1; i <= k; i++, p *= -1) {",
            "    (ret += p * 1ll * nCk(k, i) % MOD * binExp(k - i, n) % MOD",
            "            + MOD) %= MOD;",
            "  }",
            "  return ret * iFact[k] % MOD;",
            "}"
        ],
        "description": "O(k * log(n))"
    },
    "Linear Inverse": {
        "prefix": "LINEARINVERSE",
        "body": [
            "inv[1] = fact[0] = ifact[0] = 1;",
            "for (int i = 2; i < N; i++) inv[i] = (ll)inv[MOD % i] * (MOD - MOD / i) % MOD;",
            "for (int i = 1; i < N; i++) fact[i] = (ll)fact[i - 1] * i % MOD;",
            "for (int i = 1; i < N; i++) ifact[i] = (ll)ifact[i - 1] * inv[i] % MOD;"
        ],
        "description": "O(n)"
    },
    "Aho Corasick": {
        "prefix": "AHOCORASICK",
        "body": [
            "struct AC {",
            "  int N, P;",
            "  const int A = 26;",
            "  vector<vector<int>> next;",
            "  vector<int> link, out_link;",
            "  vector<vector<int>> out;",
            "",
            "  AC() : N(0), P(0) {",
            "    node();",
            "  }",
            "",
            "  int node() {",
            "    next.emplace_back(A, 0);",
            "    link.emplace_back(0);",
            "    out_link.emplace_back(0);",
            "    out.emplace_back(0);",
            "    return N++;",
            "  }",
            "",
            "  inline int get(char c) {",
            "    return c - 'a';",
            "  }",
            "",
            "  int add_pattern(const string T) {",
            "    int u = 0;",
            "    for (auto c : T) {",
            "      if (!next[u][get(c)]) next[u][get(c)] = node();",
            "      u = next[u][get(c)];",
            "    }",
            "    out[u].push_back(P);",
            "    return P++;",
            "  }",
            "",
            "  void compute() {",
            "    queue<int> q;",
            "    for (q.push(0); !q.empty(); ) {",
            "      int u = q.front();",
            "      q.pop();",
            "      for (int c = 0; c < A; ++c) {",
            "        int v = next[u][c];",
            "        if (!v) {next[u][c] = next[link[u]][c];}",
            "        else {",
            "          link[v] = u ? next[link[u]][c] : 0;",
            "          out_link[v] =",
            "            out[link[v]].empty() ? out_link[link[v]] : link[v];",
            "          q.push(v);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  int advance(int u, char c) {",
            "    while (u && !next[u][get(c)]) u = link[u];",
            "    u = next[u][get(c)];",
            "    return u;",
            "  }",
            "",
            "  void match(const string S) {",
            "    int u = 0;",
            "    for (auto c : S) {",
            "      u = advance(u, c);",
            "      for (int v = u; v; v = out_link[v]) {",
            "        for (auto p : out[v]) cout << \"match \" << p << endl;",
            "      }",
            "    }",
            "  }",
            "};",
            "// Don't forget to call compute()!"
        ],
        "description": "O(|text| + |patterns|)"
    },
    "Trie": {
        "prefix": "TRIE",
        "body": [
            "struct Trie {",
            "  const int A = 26;",
            "  int N;",
            "  vector<vector<int>> next;",
            "  vector<int> cnt;",
            "",
            "  Trie() : N(0) {",
            "    node();",
            "  }",
            "",
            "  int node() {",
            "    next.emplace_back(A, -1);",
            "    cnt.emplace_back(0);",
            "    return N++;",
            "  }",
            "",
            "  inline int get(char c) {",
            "    return c - 'a';",
            "  }",
            "",
            "  inline void insert(string s) {",
            "    int cur = 0;",
            "    for (char c : s) {",
            "      int to = get(c);",
            "      if (next[cur][to] == -1)",
            "        next[cur][to] = node();",
            "      cur = next[cur][to];",
            "    }",
            "    cnt[cur]++;",
            "  }",
            "",
            "  inline bool find(string s) {",
            "    int cur = 0;",
            "    for (char c : s) {",
            "      int to = get(c);",
            "      if (next[cur][to] == -1) return false;",
            "      cur = next[cur][to];",
            "    }",
            "    return (cnt[cur] != 0);",
            "  }",
            "",
            "  // Doesn't check for existence",
            "  inline void erase(string s) {",
            "    int cur = 0;",
            "    for (char c : s) {",
            "      int to = get(c);",
            "      cur = next[cur][to];",
            "    }",
            "    cnt[cur]--;",
            "  }",
            "",
            "  vector<string> dfs() {",
            "    stack<pair<int, int>> st;",
            "    string s;",
            "    vector<string> ret;",
            "",
            "    for (st.push({0, -1}), s.push_back('$'); !st.empty(); ) {",
            "      auto [u, c] = st.top();",
            "      st.pop();",
            "      s.pop_back();",
            "      c++;",
            "      if (c < A) {",
            "        st.push({u, c});",
            "        s.push_back(c + 'a');",
            "        int v = next[u][c];",
            "        if (~v) {",
            "          if (cnt[v])",
            "            ret.emplace_back(s);",
            "          st.push({v, -1});",
            "          s.push_back('$');",
            "        }",
            "      }",
            "    }",
            "",
            "    return ret;",
            "  }",
            "};"
        ],
        "description": "O(|patterns|)"
    },
    "Palindromic Tree": {
        "prefix": "PALINDROMICTREE",
        "body": [
            "class PalindromicTree {",
            "private:",
            "  int A;",
            "  string s;",
            "  int last, ptr;",
            "  vector<int> link, len, occ, depth;",
            "  vector<vector<int>> nxt;",
            "",
            "  void init(int sz) {",
            "    link.resize(sz, 0), len.resize(sz, 0), occ.resize(sz, 0), depth.resize(sz, 0);",
            "    nxt.resize(sz, vector<int>(A, 0));",
            "    len[1] = -1, len[2] = 0, link[1] = link[2] = 1, last = ptr = 2;",
            "  }",
            "",
            "  void feed(int at) {",
            "    while (s[at - len[last] - 1] != s[at]) last = link[last];",
            "    int ch = s[at] - 'a', temp = link[last];",
            "    while (s[at - len[temp] - 1] != s[at]) temp = link[temp];",
            "    if (!nxt[last][ch]) {",
            "      nxt[last][ch] = ++ptr, len[ptr] = len[last] + 2;",
            "      link[ptr] = len[ptr] == 1 ? 2 : nxt[temp][ch];",
            "      depth[ptr] = depth[link[ptr]] + 1;",
            "      palindromes.emplace_back(at - len[ptr], at);",
            "    }",
            "    last = nxt[last][ch], ++occ[last];",
            "  }",
            "",
            "public:",
            "  vector<pair<int, int>> palindromes;",
            "",
            "  PalindromicTree(string s, int A = 26) {",
            "    int n = s.length();",
            "    this->s = '0' + s;",
            "    this->A = A;",
            "    init(n + 3);",
            "    for (int i = 1; i <= n; ++i) feed(i);",
            "  }",
            "};"
        ],
        "description": "O(|text|)"
    },
    "Suffix Array": {
        "prefix": "SUFFIXARRAY",
        "body": [
            "class SuffixArray {",
            "  // Everything is 0-indexed",
            "private:",
            "  int n, logn;",
            "  string s; // Suffix array will be built for this string",
            "  vector<int> cnt, nxt; // Internal",
            "  vector<bool> bh, b2h; // Internal",
            "  vector<vector<int>> lcp_sparse; // lcp_sparse[i][j] = min(lcp[j], ..., lcp[j + (1 << i) - 1])",
            "  bool lcp_built, lcp_sparse_built;",
            "",
            "  void init() {",
            "    cnt.resize(n, 0), nxt.resize(n, 0), bh.resize(n, 0), b2h.resize(n, 0), SA.resize(n, 0), iSA.resize(n, 0), lcp.resize(n, 0);",
            "    lcp_sparse.resize(logn, vector<int>(n, 0));",
            "    lcp_built = lcp_sparse_built = false;",
            "  }",
            "",
            "  void build_SA() {",
            "    for (int i = 0; i < n; i++) SA[i] = i;",
            "    sort(SA.begin(), SA.end(), [&](int i, int j) { return s[i] < s[j]; });",
            "",
            "    for (int i = 0; i < n; i++) {",
            "      bh[i] = i == 0 || s[SA[i]] != s[SA[i - 1]];",
            "      b2h[i] = 0;",
            "    }",
            "",
            "    for (int h = 1; h < n; h <<= 1) {",
            "      int tot = 0;",
            "      for (int i = 0, j; i < n; i = j) {",
            "        j = i + 1;",
            "        while (j < n && !bh[j]) j++;",
            "        nxt[i] = j; tot++;",
            "      } if (tot == n) break;",
            "",
            "      for (int i = 0; i < n; i = nxt[i]) {",
            "        for (int j = i; j < nxt[i]; j++) iSA[SA[j]] = i;",
            "        cnt[i] = 0;",
            "      }",
            "",
            "      cnt[iSA[n - h]]++;",
            "      b2h[iSA[n - h]] = 1;",
            "      for (int i = 0; i < n; i = nxt[i]) {",
            "        for (int j = i; j < nxt[i]; j++) {",
            "          int s = SA[j] - h;",
            "          if (s < 0) continue;",
            "          int head = iSA[s];",
            "          iSA[s] = head + cnt[head]++;",
            "          b2h[iSA[s]] = 1;",
            "        }",
            "        for (int j = i; j < nxt[i]; j++) {",
            "          int s = SA[j] - h;",
            "          if (s < 0 || !b2h[iSA[s]]) continue;",
            "          for (int k = iSA[s] + 1; !bh[k] && b2h[k]; k++) b2h[k] = 0;",
            "        }",
            "      }",
            "      for (int i = 0; i < n; i++) {",
            "        SA[iSA[i]] = i;",
            "        if (b2h[i]) bh[i] = true;",
            "      }",
            "    }",
            "    for (int i = 0; i < n; i++) iSA[SA[i]] = i;",
            "  }",
            "",
            "  void build_lcp() {",
            "    lcp_built = true;",
            "    for (int i = 0, k = 0; i < n; i++) {",
            "      if (iSA[i] == n - 1) {",
            "        k = 0;",
            "        lcp[n - 1] = 0;",
            "        continue;",
            "      }",
            "      int j = SA[iSA[i] + 1];",
            "      while (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;",
            "      lcp[iSA[i]] = k;",
            "      if (k) k--;",
            "    }",
            "  }",
            "",
            "  void build_lcp_sparse() {",
            "    if (!lcp_built) build_lcp();",
            "    lcp_sparse_built = true;",
            "    for (int i = 0; i < n; i++) lcp_sparse[0][i] = lcp[i];",
            "    for (int i = 1; i < logn; i++) {",
            "      for (int j = 0; j < n; j++) {",
            "        lcp_sparse[i][j] = min(lcp_sparse[i - 1][j], lcp_sparse[i - 1][min(n - 1, j + (1 << (i - 1)))]);",
            "      }",
            "    }",
            "  }",
            "",
            "public:",
            "",
            "  vector<int> SA, iSA; // SA is the suffix array, iSA[i] stores the rank of the i'th suffix",
            "  vector<int> lcp; // Stores lcp of SA[i] and SA[i + 1]; lcp[n - 1] = 0",
            "",
            "  // O(nlog(n))",
            "  SuffixArray(string s) {",
            "    n = s.length();",
            "    logn = 32 - __builtin_clz(n);",
            "    this->s = s;",
            "    init();",
            "    build_SA();",
            "  }",
            "",
            "  // Returns (l, r) such that l <= from <= r and lcp(SA[l], SA[r]) >= min_lcp",
            "  // O(log(n))",
            "  pair<int, int> min_lcp_range(int from, int min_lcp) {",
            "    assert(0 <= from and from < n);",
            "    assert(min_lcp <= n - SA[from]); // min_lcp should be >= length of the suffix",
            "    if (!lcp_sparse_built) build_lcp_sparse();",
            "",
            "    int r = from;",
            "    for (int i = logn - 1; i >= 0; i--) {",
            "      int jump = 1 << i;",
            "      if (r + jump < n and lcp_sparse[i][r] >= min_lcp) r += jump;",
            "    }",
            "",
            "    int l = from;",
            "    for (int i = logn - 1; i >= 0; i--) {",
            "      int jump = 1 << i;",
            "      if (l - jump >= 0 and lcp_sparse[i][l - jump] >= min_lcp) l -= jump;",
            "    }",
            "",
            "    return make_pair(l, r);",
            "  }",
            "",
            "  // Returns lcp(SA[l], SA[r - 1])",
            "  // O(1)",
            "  int range_lcp(int l, int r) {",
            "    assert(0 <= l and l < r and r <= n);",
            "    if (!lcp_sparse_built) build_lcp_sparse();",
            "    int msb = 31 - __builtin_clz(r - l);",
            "    return min(lcp_sparse[msb][l], lcp_sparse[msb][r - (1 << msb)]);",
            "  }",
            "",
            "  // Returns lcp of the suffixes s[i...n-1] and s[j...n-1]",
            "  // O(1)",
            "  int suffix_lcp(int i, int j) {",
            "    if (i == j) return n - i;",
            "    i = iSA[i], j = iSA[j];",
            "    if (j < i) swap(i, j);",
            "    return range_lcp(i, j);",
            "  }",
            "",
            "  // Compares the suffixes s[i...n-1] and s[j...n-1]",
            "  // O(1)",
            "  bool compare(int i, int j) {",
            "    int len_i = n - i, len_j = n - j;",
            "    int lcp = suffix_lcp(i, j);",
            "    if (lcp >= len_i or lcp >= len_j) return len_i < len_j;",
            "    return s[i + lcp] < s[j + lcp];",
            "  }",
            "};"
        ],
        "description": "O(n * log(n))"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "template<class T>",
            "class BIT {",
            "public:",
            "  int n;",
            "  vector<T> f;",
            "  BIT(int n) : n(n) {",
            "    f.resize(n + 1, (T)0);",
            "  }",
            "  BIT(const vector<T> &a) { // O(n)",
            "    n = a.size();",
            "    f.assign(n + 1, (T)0);",
            "    for (int i = 1; i <= n; i++) {",
            "      f[i] += a[i - 1];",
            "      if (i + (i & -i) <= n) {",
            "        f[i + (i & -i)] += f[i];",
            "      }",
            "    }",
            "  }",
            "  void update(int p, T v) {",
            "    while (p <= n) f[p] += v, p += p & -p;",
            "  }",
            "  T pref(int p) {",
            "    T ret = 0;",
            "    while (p) ret += f[p], p -= p & -p;",
            "    return ret;",
            "  }",
            "  T range(int l, int r) {",
            "    return pref(r) - pref(l - 1);",
            "  }",
            "};"
        ],
        "description": "O(log(n))"
    },
    "BIT2D": {
        "prefix": "BIT2D",
        "body": [
            "template<class T>",
            "class BIT2D {",
            "public:",
            "  int n, m;",
            "  vector<BIT<T>> f;",
            "  BIT2D(int n, int m) : n(n) {",
            "    f.resize(n + 1, BIT<T>(m));",
            "  }",
            "  BIT2D(const vector<vector<T>> &grid) { // O(n^2 * log(n))",
            "    n = grid.size();",
            "    m = grid[0].size();",
            "    vector<vector<T>> a(n + 1, vector<T>(m, (T)0));",
            "    for (int i = 0; i < n; i++) {",
            "      for (int j = 0; j < m; j++) {",
            "        int fi = i + 1;",
            "        while (fi <= n) {",
            "          a[fi][j] += grid[i][j];",
            "          fi += fi & -fi;",
            "        }",
            "      }",
            "    }",
            "    f.emplace_back(0);",
            "    for (int i = 1; i <= n; i++) {",
            "      f.emplace_back(BIT<T>(a[i]));",
            "    }",
            "  }",
            "  void update(int p, int q, T v) {",
            "    while (p <= n) f[p].update(q, v), p += p & -p;",
            "  }",
            "  T pref(int p, int q) {",
            "    T ret = 0;",
            "    while (p) ret += f[p].pref(q), p -= p & -p;",
            "    return ret;",
            "  }",
            "  T range(int x1, int y1, int x2, int y2) {",
            "    return pref(x2, y2) - pref(x2, y1 - 1) - pref(x1 - 1, y2) + pref(x1 - 1, y1 - 1);",
            "  }",
            "};"
        ],
        "description": "O(log^2(n))"
    },
    "DSU": {
        "prefix": "DSU",
        "body": [
            "struct DSU {",
            "  int n, sz;",
            "  vector<int> p; // root: -1 * component size, otherwise: parent",
            "  DSU(int n) : n(n), sz(n), p(n, -1) {}",
            "  bool same(int a, int b) { return root(a) == root(b); }",
            "  int root(int a) { return p[a] < 0 ? a : (p[a] = root(p[a])); }",
            "  int size(int a) { return -p[root(a)]; }",
            "  int size() { return sz; }",
            "  bool merge(int a, int b, bool rank = true) {",
            "    int x = root(a), y = root(b);",
            "    if (x == y) return false;",
            "    sz--;",
            "    if (rank and -p[x] < -p[y]) swap(x, y);",
            "    p[x] += p[y];",
            "    p[y] = x;",
            "    return true;",
            "  }",
            "  vector<vector<int>> groups() {",
            "    vector<int> _root(n), sz(n);",
            "    for (int i = 0; i < n; i++) _root[i] = root(i), sz[_root[i]]++;",
            "    vector<vector<int>> g(n);",
            "    for (int i = 0; i < n; i++) g[i].reserve(sz[i]);",
            "    for (int i = 0; i < n; i++) g[_root[i]].push_back(i);",
            "    auto empty = [&](const vector<int>&v) { return v.empty(); };",
            "    g.erase(remove_if(g.begin(), g.end(), empty), g.end());",
            "    return g;",
            "  }",
            "};"
        ],
        "description": "O(n)"
    },
    "Sparse Table": {
        "prefix": "SPARSETABLE",
        "body": [
            "template <typename T, class F = function<T(const T&, const T&)>>",
            "class SparseTable {",
            " public:",
            "  int n;",
            "  vector<vector<T>> mat;",
            "  F func;",
            " ",
            "  SparseTable(const vector<T>& a, const F& f) : func(f) {",
            "    n = static_cast<int>(a.size());",
            "    int max_log = 32 - __builtin_clz(n);",
            "    mat.resize(max_log);",
            "    mat[0] = a;",
            "    for (int j = 1; j < max_log; j++) {",
            "      mat[j].resize(n - (1 << j) + 1);",
            "      for (int i = 0; i <= n - (1 << j); i++) {",
            "        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
            "      }",
            "    }",
            "  }",
            " ",
            "  T get(int from, int to) const {",
            "    assert(0 <= from && from <= to && to <= n - 1);",
            "    int lg = 32 - __builtin_clz(to - from + 1) - 1;",
            "    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);",
            "  }",
            "};",
            "// SparseTable<long long> mn(v, [&](long long i, long long j) { return min(i, j); });"
        ],
        "description": "Initialize O(n * log(n)) | Query O(1)"
    },
    "Modular": {
        "prefix": "MODULAR",
        "body": [
            "template<typename T>",
            "T inverse(T a, T m) {",
            "  T u = 0, v = 1;",
            "  while (a != 0) {",
            "    T t = m / a;",
            "    m -= t * a; swap(a, m);",
            "    u -= t * v; swap(u, v);",
            "  }",
            "  assert(m == 1);",
            "  return u;",
            "}",
            "",
            "template<typename T>",
            "class Modular {",
            "public:",
            "  using Type = typename decay<decltype(T::value)>::type;",
            "",
            "  constexpr Modular() : value() {}",
            "  template<typename U>",
            "  Modular(const U&x) {",
            "    value = normalize(x);",
            "  }",
            "",
            "  template<typename U>",
            "  static Type normalize(const U&x) {",
            "    Type v;",
            "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);",
            "    else v = static_cast<Type>(x % mod());",
            "    if (v < 0) v += mod();",
            "    return v;",
            "  }",
            "",
            "  const Type&operator()() const { return value; }",
            "  template<typename U>",
            "  explicit operator U() const { return static_cast<U>(value); }",
            "  constexpr static Type mod() { return T::value; }",
            "",
            "  Modular&operator+=(const Modular&other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
            "  Modular&operator-=(const Modular&other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
            "  template<typename U> Modular&operator+=(const U&other) { return *this += Modular(other); }",
            "  template<typename U> Modular&operator-=(const U&other) { return *this -= Modular(other); }",
            "  Modular&operator++() { return *this += 1; }",
            "  Modular&operator--() { return *this -= 1; }",
            "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }",
            "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }",
            "  Modular operator-() const { return Modular(-value); }",
            "",
            "  template<typename U = T>",
            "  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type&operator*=(const Modular&rhs) {",
            "#ifdef _WIN32",
            "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
            "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
            "    asm (",
            "      \"divl %4; \\n\\t\"",
            "      : \"=a\" (d), \"=d\" (m)",
            "      : \"d\" (xh), \"a\" (xl), \"r\" (mod())",
            "      );",
            "    value = m;",
            "#else",
            "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "#endif",
            "    return *this;",
            "  }",
            "  template<typename U = T>",
            "  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type&operator*=(const Modular&rhs) {",
            "    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
            "    value = normalize(value * rhs.value - q * mod());",
            "    return *this;",
            "  }",
            "  template<typename U = T>",
            "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type&operator*=(const Modular&rhs) {",
            "    value = normalize(value * rhs.value);",
            "    return *this;",
            "  }",
            "",
            "  Modular&operator/=(const Modular&other) { return *this *= Modular(inverse(other.value, mod())); }",
            "",
            "  friend const Type&abs(const Modular&x) { return x.value; }",
            "",
            "  template<typename U>",
            "  friend bool operator==(const Modular<U>&lhs, const Modular<U>&rhs);",
            "",
            "  template<typename U>",
            "  friend bool operator<(const Modular<U>&lhs, const Modular<U>&rhs);",
            "",
            "  template<typename V, typename U>",
            "  friend V&operator>>(V&stream, Modular<U>&number);",
            "",
            "private:",
            "  Type value;",
            "};",
            "",
            "template<typename T> bool operator==(const Modular<T>&lhs, const Modular<T>&rhs) { return lhs.value == rhs.value; }",
            "template<typename T, typename U> bool operator==(const Modular<T>&lhs, U rhs) { return lhs == Modular<T>(rhs); }",
            "template<typename T, typename U> bool operator==(U lhs, const Modular<T>&rhs) { return Modular<T>(lhs) == rhs; }",
            "",
            "template<typename T> bool operator!=(const Modular<T>&lhs, const Modular<T>&rhs) { return !(lhs == rhs); }",
            "template<typename T, typename U> bool operator!=(const Modular<T>&lhs, U rhs) { return !(lhs == rhs); }",
            "template<typename T, typename U> bool operator!=(U lhs, const Modular<T>&rhs) { return !(lhs == rhs); }",
            "",
            "template<typename T> bool operator<(const Modular<T>&lhs, const Modular<T>&rhs) { return lhs.value < rhs.value; }",
            "",
            "template<typename T> Modular<T> operator+(const Modular<T>&lhs, const Modular<T>&rhs) { return Modular<T>(lhs) += rhs; }",
            "template<typename T, typename U> Modular<T> operator+(const Modular<T>&lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
            "template<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>&rhs) { return Modular<T>(lhs) += rhs; }",
            "",
            "template<typename T> Modular<T> operator-(const Modular<T>&lhs, const Modular<T>&rhs) { return Modular<T>(lhs) -= rhs; }",
            "template<typename T, typename U> Modular<T> operator-(const Modular<T>&lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
            "template<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>&rhs) { return Modular<T>(lhs) -= rhs; }",
            "",
            "template<typename T> Modular<T> operator*(const Modular<T>&lhs, const Modular<T>&rhs) { return Modular<T>(lhs) *= rhs; }",
            "template<typename T, typename U> Modular<T> operator*(const Modular<T>&lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
            "template<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>&rhs) { return Modular<T>(lhs) *= rhs; }",
            "",
            "template<typename T> Modular<T> operator/(const Modular<T>&lhs, const Modular<T>&rhs) { return Modular<T>(lhs) /= rhs; }",
            "template<typename T, typename U> Modular<T> operator/(const Modular<T>&lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
            "template<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>&rhs) { return Modular<T>(lhs) /= rhs; }",
            "",
            "template<typename T, typename U>",
            "Modular<T> power(const Modular<T>&a, const U&b) {",
            "  assert(b >= 0);",
            "  Modular<T> x = a, res = 1;",
            "  U p = b;",
            "  while (p > 0) {",
            "    if (p & 1) res *= x;",
            "    x *= x;",
            "    p >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "template<typename T>",
            "bool IsZero(const Modular<T>&number) {",
            "  return number() == 0;",
            "}",
            "",
            "template<typename T>",
            "string to_string(const Modular<T>&number) {",
            "  return to_string(number());",
            "}",
            "",
            "// U == std::ostream? but done this way because of fastoutput",
            "template<typename U, typename T>",
            "U&operator<<(U&stream, const Modular<T>&number) {",
            "  return stream << number();",
            "}",
            "",
            "// U == std::istream? but done this way because of fastinput",
            "template<typename U, typename T>",
            "U&operator>>(U&stream, Modular<T>&number) {",
            "  typename common_type<typename Modular<T>::Type, long long>::type x;",
            "  stream >> x;",
            "  number.value = Modular<T>::normalize(x);",
            "  return stream;",
            "}",
            "",
            "/*",
            "   using ModType = int;",
            "",
            "   struct VarMod { static ModType value; };",
            "   ModType VarMod::value;",
            "   ModType& md = VarMod::value;",
            "   using Mint = Modular<VarMod>;",
            "",
            "   // dynamically set modulo in solution",
            "   {",
            "    mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());",
            "    while (true) {",
            "      md = (int) 1e8 + rng() % (int) 9e8;",
            "      bool pr = true;",
            "      for (int i = 2; i * i <= md; i++) {",
            "        if (md % i == 0) {",
            "          pr = false;",
            "          break;",
            "        }",
            "      }",
            "      if (pr) {",
            "        break;",
            "      }",
            "    }",
            "  }",
            " */",
            "",
            "constexpr int md = (int) 1e9 + 7;",
            "using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
            "",
            "/*vector<Mint> fact(1, 1);",
            "   vector<Mint> inv_fact(1, 1);",
            "",
            "   Mint C(int n, int k) {",
            "   if (k < 0 || k > n) {",
            "    return 0;",
            "   }",
            "   while ((int) fact.size() < n + 1) {",
            "    fact.push_back(fact.back() * (int) fact.size());",
            "    inv_fact.push_back(1 / fact.back());",
            "   }",
            "   return fact[n] * inv_fact[k] * inv_fact[n - k];",
            "   }*/",
            ""
        ],
        "description": "Modular"
    },
    "Linear Sieve": {
        "prefix": "SIEVE",
        "body": [
            "int prime[N], prime_sz, pfact[N];",
            "void sieve() {",
            "  pfact[1] = 1;",
            "  for (int i = 2; i < N; ++i) {",
            "    if (!pfact[i]) prime[prime_sz++] = i, pfact[i] = i;",
            "    for (int j = 0; j < prime_sz and i * prime[j] < N and",
            "         (!j or j and i % prime[j - 1]); ++j) {",
            "      pfact[i * prime[j]] = prime[j];",
            "    }",
            "  }",
            "}"
        ],
        "description": "O(n)"
    },
    "Z Algorithm": {
        "prefix": "ZALGORITHM",
        "body": [
            "template <typename T>",
            "vector<int> z_function(int n, const T &s) {",
            "  vector<int> z(n, n);",
            "  int l = 0, r = 0;",
            "  for (int i = 1; i < n; i++) {",
            "    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));",
            "    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
            "      z[i]++;",
            "    }",
            "    if (i + z[i] - 1 > r) {",
            "      l = i;",
            "      r = i + z[i] - 1;",
            "    }",
            "  }",
            "  return z;",
            "}",
            " ",
            "template <typename T>",
            "vector<int> z_function(const T &s) {",
            "  return z_function((int) s.size(), s);",
            "}"
        ],
        "description": "O(|text|)"
    },
    "Coordinate Compression": {
        "prefix": "COMPRESS",
        "body": [
            "// Returns a vector of the sorted unique elements",
            "// If update_a is true, then changes the elements in a to the corresponding compressed values",
            "template<typename T>",
            "vector<T> compress(vector<T> &a, bool update_a = true) {",
            "  int n = a.size();",
            "  vector<pair<T, int>> pairs(n);",
            "  for (int i = 0; i < n; ++i) {",
            "    pairs[i] = {a[i], i};",
            "  }",
            "  sort(pairs.begin(), pairs.end());",
            "  vector<T> ret;",
            "  int at = 0;",
            "  for (int i = 0; i < n; i++) {",
            "    if (update_a) a[pairs[i].second] = at;",
            "    if (i == n - 1 or pairs[i].first != pairs[i + 1].first) at++;",
            "    if (i == 0 or pairs[i].first != pairs[i - 1].first) {",
            "      ret.push_back(pairs[i].first);",
            "    }",
            "  }",
            "  return ret;",
            "}"
        ],
        "description": "O(n * log(n))"
    },
    "Matrix": {
        "prefix": "MATRIX",
        "body": [
            "const int MOD = 998244353;",
            "typedef vector<int> row;",
            "typedef vector<row> matrix;",
            "inline int add(const int &a, const int &b) {",
            "  int c = a + b;",
            "  if (c >= MOD) c -= MOD;",
            "  return c;",
            "}",
            "inline int mult(const int &a, const int &b) {",
            "  return (long long)a * b % MOD;",
            "}",
            "matrix operator+(const matrix &m1, const matrix &m2) {",
            "  int r = m1.size();",
            "  int c = m1.back().size();",
            "  matrix ret(r, row(c));",
            "  for (int i = 0; i < r; i++) {",
            "    for (int j = 0; j < c; j++) {",
            "      ret[i][j] = add(m1[i][j], m2[i][j]);",
            "    }",
            "  }",
            "  return ret;",
            "}",
            "matrix operator*(const matrix &m1, const int m2) {",
            "  int r = m1.size();",
            "  int c = m1.back().size();",
            "  matrix ret(r, row(c));",
            "  for (int i = 0; i < r; i++) {",
            "    for (int j = 0; j < c; j++) {",
            "      ret[i][j] = mult(m1[i][j], m2);",
            "    }",
            "  }",
            "  return ret;",
            "}",
            "matrix operator*(const matrix &m1, const matrix &m2) {",
            "  int r = m1.size();",
            "  int m = m1.back().size();",
            "  int c = m2.back().size();",
            "  matrix ret(r, row(c, 0));",
            "  for (int i = 0; i < r; i++) {",
            "    for (int k = 0; k < m; k++) {",
            "      for (int j = 0; j < c; j++) {",
            "        ret[i][j] = add(ret[i][j], mult(m1[i][k], m2[k][j]));",
            "      }",
            "    }",
            "  }",
            "  return ret;",
            "}",
            "matrix one(int dim) {",
            "  matrix ret(dim, row(dim, 0));",
            "  for (int i = 0; i < dim; i++) {",
            "    ret[i][i] = 1;",
            "  }",
            "  return ret;",
            "}",
            "matrix operator^(const matrix &m, const int &e) {",
            "  if (e == 0) return one(m.size());",
            "  matrix sqrtm = m ^ (e / 2);",
            "  matrix ret = sqrtm * sqrtm;",
            "  if (e & 1) ret = ret * m;",
            "  return ret;",
            "}"
        ],
        "description": "Matrix"
    },
    "MergeSortTree": {
        "prefix": "MERGESORTTREE",
        "body": [
            "template<typename T, typename QT, class C = function<bool(const T&, const T&)>, class F = function<QT(const vector<T>&, const T&)>, class M = function<QT(const QT&, const QT&)>>",
            "class MergeSortTree {",
            "  int n;",
            "  vector<vector<T>> st;",
            "  C order;",
            "  QT fail_return;",
            "  F range_query;",
            "  M merge_query;",
            "  void build(const vector<T> &a, int stI, int L, int R) {",
            "    if (L == R) {",
            "      st[stI] = vector<T>(1, a[L - 1]);",
            "      return;",
            "    }",
            "",
            "    int mid = (L + R) >> 1;",
            "    build(a, stI << 1, L, mid);",
            "    build(a, stI << 1 | 1, mid + 1, R);",
            "",
            "    vector<T> &vL = st[stI << 1];",
            "    vector<T> &vR = st[stI << 1 | 1];",
            "    vector<T> &vC = st[stI];",
            "",
            "    for (int iL = 0, iR = 0; iL < vL.size() or iR < vR.size(); ) {",
            "      if (iL == vL.size()) vC.push_back(vR[iR++]);",
            "      else if (iR == vR.size()) vC.push_back(vL[iL++]);",
            "      else if (order(vL[iL], vR[iR])) vC.push_back(vL[iL++]);",
            "      else vC.push_back(vR[iR++]);",
            "    }",
            "  }",
            "  QT query(int stI, int L, int R, int l, int r, T val) {",
            "    if (l <= L && R <= r) return range_query(st[stI], val);",
            "",
            "    int mid = (L + R) >> 1;",
            "    if (r <= mid) return query(stI << 1, L, mid, l, r, val);",
            "    else if (mid + 1 <= l) return query(stI << 1 | 1, mid + 1, R, l, r, val);",
            "    else return merge_query(",
            "        query(stI << 1, L, mid, l, mid, val),",
            "        query(stI << 1 | 1, mid + 1, R, mid + 1, r, val)",
            "        );",
            "  }",
            "public:",
            "  /*",
            "     Params:",
            "     a - vector of numbers to build the tree on",
            "     fail_return - value to return if the query range is invalid",
            "     range_query - if the query interval includes the current recursive tree interval, then this function is called",
            "     merge_query - called to merge query values from the two children",
            "     order - comparator function following usual convention, used to build the tree",
            "   */",
            "  MergeSortTree(const vector<T> &a, QT fail_return, const F &range_query, const M &merge_query, const C order = [] (const T&a, const T&b) { return a < b; }) {",
            "    n = static_cast<int>(a.size());",
            "    st.resize(4 * n + 1);",
            "    this->fail_return = fail_return;",
            "    this->range_query = range_query;",
            "    this->merge_query = merge_query;",
            "    this->order = order;",
            "    build(a, 1, 1, n);",
            "  }",
            "  QT query(int l, int r, T val) { // range [l, r], 1-based index",
            "    if (r < 1 || n < l || r < l) return fail_return;",
            "    l = max(l, 1); r = min(r, n);",
            "    return query(1, 1, n, l, r, val);",
            "  }",
            "};",
            "/*",
            "// st.query(l, r, v) returns left-most index in vector a that is equal to v",
            "MergeSortTree<int, int> st(",
            "  indices,",
            "  -1,",
            "  [&](const vector<int> &v, int val) {",
            "    auto it = lower_bound(v.begin(), v.end(), val, [&](int i, int val) {",
            "      return a[i - 1] < val;",
            "    });",
            "    if (it == v.end() or a[*it - 1] != val) return -1;",
            "    return *it;",
            "  },",
            "  [&](int qL, int qR) { return qL == -1 ? qR : qL; },",
            "  [&](int i, int j) { return a[i - 1] != a[j - 1] ? a[i - 1] < a[j - 1] : i < j; }",
            ");",
            "*/"
        ],
        "description": "Initialize O(n * log(n)) | Query O(log(n))"
    },
    "KMP Algorithm": {
        "prefix": "KMP",
        "body": [
            "// Returns 0-indexed positions of occurrences of s in w",
            "template <typename T>",
            "vector<int> kmp_search(int n, const T &s, int m, const T &w, const vector<int> &p) {",
            "  assert(n >= 1 && (int) p.size() == n);",
            "  vector<int> res;",
            "  int k = 0;",
            "  for (int i = 0; i < m; i++) {",
            "    while (k > 0 && (k == n || !(w[i] == s[k]))) {",
            "      k = p[k - 1];",
            "    }",
            "    if (w[i] == s[k]) {",
            "      k++;",
            "    }",
            "    if (k == n) {",
            "      res.push_back(i - n + 1);",
            "    }",
            "  }",
            "  return res;",
            "}",
            "template <typename T>",
            "vector<int> kmp_search(const T &s, const T &w, const vector<int> &p) {",
            "  return kmp_search((int) s.size(), s, (int) w.size(), w, p);",
            "}"
        ],
        "description": "O(|text|)"
    },
    "Prefix Function": {
        "prefix": "PREFIXFUNCTION",
        "body": [
            "template <typename T>",
            "vector<int> prefix_function(int n, const T &s) {",
            "  vector<int> p(n, 0);",
            "  int k = 0;",
            "  for (int i = 1; i < n; i++) {",
            "    while (k > 0 && !(s[i] == s[k])) {",
            "      k = p[k - 1];",
            "    }",
            "    if (s[i] == s[k]) {",
            "      k++;",
            "    }",
            "    p[i] = k;",
            "  }",
            "  return p;",
            "}",
            "template <typename T>",
            "vector<int> prefix_function(const T &s) {",
            "  return prefix_function((int) s.size(), s);",
            "}"
        ],
        "description": "O(|text|)"
    },
    "Prefix Function Automaton": {
        "prefix": "PREFIXFUNCTIONAUTOMATON",
        "body": [
            "template<typename T>",
            "vector<vector<int>> prefix_function_automaton(const T &s, int alphabet_size, int smallest_alphabet) {",
            "  int n = s.size();",
            "  vector<int> pf = prefix_function(s);",
            "  vector<vector<int>> automaton(n + 1, vector<int>(alphabet_size));",
            "  for (int i = 0; i <= n; i++) {",
            "    for (int c = 0; c < alphabet_size; c++) {",
            "      if (i < n and s[i] == smallest_alphabet + c) {",
            "        automaton[i][c] = i + 1;",
            "      }",
            "      else {",
            "        automaton[i][c] = i == 0 ? 0 : automaton[pf[i - 1]][c];",
            "      }",
            "    }",
            "  }",
            "  return automaton;",
            "}"
        ],
        "description": "O(|text|)"
    },
    "GCC Optimizations": {
        "prefix": "GCCOPTIMIZATIONS",
        "body": [
            "#pragma GCC optimize(\"O3,unroll-loops\")",
            "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\") // use avx for older judges"
        ],
        "description": "GCC Optimizations"
    },
    "Bit Manipulations": {
        "prefix": "BITMANIPULATIONS",
        "body": [
            "__attribute__((target(\"popcnt\"))) inline int popcnt(const u64 &a) {",
            "  return _mm_popcnt_u64(a);",
            "}",
            "inline int lsb(const u64 &a) { return a ? __builtin_ctzll(a) : 64; }",
            "inline int msb(const u64 &a) { return a ? 63 - __builtin_clzll(a) : -1; }",
            "template <typename T>",
            "inline int gbit(const T &a, int i) {",
            "  return (a >> i) & 1;",
            "}",
            "template <typename T>",
            "inline void sbit(T &a, int i, bool b) {",
            "  if (gbit(a, i) != b) a ^= T(1) << i;",
            "}",
            "constexpr long long PW(int n) { return 1LL << n; }",
            "constexpr long long MSK(int n) { return (1LL << n) - 1; }",
            "// Iterate over all subsets of mask excluding null subset",
            "for (int i = mask; i > 0; i = (i - 1) & mask) {",
            "  // do stuff",
            "}",
            "// Iterate over all subsets of mask including null subset",
            "int i = mask;",
            "do {",
            "  // do stuff",
            "  i = (i - 1) & mask;",
            "} while (i != mask);"
        ],
        "description": "Bit Manipulations"
    },
    "Bitsets": {
        "prefix": "BITSETS",
        "body": [
            "/*",
            "     Useful notes:",
            "     - Bitset optimizes the space such that each bool takes 1 bit space only",
            "     - The size of bitset is fixed at compile time that is, it cant be",
            "      changed at runtime.",
            "     - Remember bitset starts its indexing backwards that is for 10110, 0 are",
            "      at 0th and 3rd indices whereas 1 are at 1st, 2nd and 4th indices.",
            "     -",
            "   */",
            "",
            "  const int M = 10;",
            "  bitset<M> bset; // Default constructor initializes with all bits 0",
            "  bset = bitset<M>(20); // Initialized with bits of 20",
            "  bset = bitset<M>(\"1100\"); // Initialized with binary representation of 12",
            "",
            "  // string constructor using custom zero/one digits",
            "  string alpha_bit_string = \"aBaaBBaB\";",
            "  bset = bitset<M>(alpha_bit_string, 0, alpha_bit_string.size(),  'a', 'B'); // [0,1,0,0,1,1,0,1]",
            "  bset = bitset<M>(\"aBaaBBaB\", 8,  'a', 'B'); // [0,1,0,0,1,1,0,1]",
            "",
            "  bset[1] = 1; // Setting lsb(the one with coefficient 2^1)",
            "  bset.count(); // Number of set bits in bitset",
            "  bset.size(); // Total number of bits in bitset",
            "  bset.size() - bset.count(); // Number of unset bits in bitset",
            "  bset.test(1); // Returns 1 if bit is set else returns 0",
            "  bset.any(); // Returns true, if atleast 1 bit is set",
            "  bset.none(); // Returns true, if none of the bits is set",
            "  bset.all(); // Returns true, if all of the bits are set",
            "  bset.set(); // Sets all bits",
            "  bset.set(4); // Sets bit 4",
            "  bset.set(4, 0); // Alternative for bset[4] = 0",
            "  bset.reset(); // Unsets all bits",
            "  bset.reset(4); // Unsets bit 4",
            "  bset.flip(); // Flips all bits",
            "  bset.flip(4); // Flips bit 4",
            "  bset._Find_first(); // first set bit",
            "  bset._Find_next(1); // first set bit after index 1",
            "  // loop over set bits",
            "  for (int i = bset._Find_first(); i < bset.size(); i = bset._Find_next(i)) {",
            "    cout << i << endl;",
            "  }",
            "  cout << bset << endl;",
            "",
            "  // All bitwise operators are overloaded",
            "  // But when doing operations on two bitsets, there sizes need to be same",
            "  bitset<M> bset2(bset);",
            "  (bset == bset2);",
            "  (bset != bset2);",
            "  (bset ^= bset2);",
            "  (bset &= bset2);",
            "  (bset |= bset2);",
            "  (bset == 6);",
            "  (bset != 6);",
            "  (bset ^= 6);",
            "  (bset &= 6);",
            "  (bset |= 6);",
            "  (bset <<= 6);",
            "  (bset >>= 6);",
            "  (~bset);",
            "",
            "  bset.to_string(); // Converts the contents of the bitset to a string",
            "  bset.to_string('O', 'X'); // Use 'O' for 0 and 'X' for 1",
            "  bset.to_ulong(); // Converts the contents of the bitset to an unsigned long integer",
            "  bset.to_ullong(); // Converts the contents of the bitset to an unsigned long long integer"
        ],
        "description": "Bitsets"
    },
    "LIS": {
        "prefix": "LIS",
        "body": [
            "template<typename T>",
            "int LIS(const vector<T> &a, bool strict) {",
            "  vector<T> v;",
            "  for (const T &i : a) {",
            "    auto it = strict ? lower_bound(v.begin(), v.end(), i) : upper_bound(v.begin(), v.end(), i);",
            "    if (it != v.end()) *it = i;",
            "    else v.push_back(i);",
            "  }",
            "  return v.size();",
            "}"
        ],
        "description": "O(n * log(n))"
    },
    "Unique": {
        "prefix": "UNIQUE",
        "body": [
            "sort($1.begin(), $1.end());",
            "$1.resize(unique($1.begin(), $1.end()) - $1.begin());$0"
        ],
        "description": "O(n * log(n))"
    },
    "Fenwick Tree": {
        "prefix": "FENWICKTREE",
        "body": [
            "template<typename T>",
            "class fenwick {",
            "public:",
            "  vector<T> fenw;",
            "  int n;",
            "",
            "  fenwick(int _n) : n(_n) {",
            "    fenw.resize(n);",
            "  }",
            "",
            "  void modify(int x, T v) {",
            "    while (x < n) {",
            "      fenw[x] += v;",
            "      x |= (x + 1);",
            "    }",
            "  }",
            "",
            "  T get(int x) {",
            "    T v{};",
            "    while (x >= 0) {",
            "      v += fenw[x];",
            "      x = (x & (x + 1)) - 1;",
            "    }",
            "    return v;",
            "  }",
            "};"
        ],
        "description": "Initialize O(n) | Update O(log(n)) | Query O(log(n))"
    },
    "C++ Template": {
        "prefix": "cptemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "#define ll long long int",
            "using namespace std;",
            "void solve()",
            "{",
            "    $0",
            "}",
            "int main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    for (int cs = 1; cs <= t; cs++)",
            "    {",
            "        // cout << \"Case #\" << cs << \": \";",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "C++ template for competitive programming"
    }
}